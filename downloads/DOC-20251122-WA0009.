


```javascript
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import RootStack from './src/navigation';

export default function App() {
  return (
    <NavigationContainer>
      <RootStack />
    </NavigationContainer>
  );
}
```



```json
{
  "name": "deo-mobile",
  "version": "1.0.0",
  "main": "App.js",
  "dependencies": {
    "@react-navigation/native": "^6.1.6",
    "@react-navigation/native-stack": "^6.9.12",
    "axios": "^1.4.0",
    "react": "18.2.0",
    "react-native": "0.71.8",
    "react-native-gesture-handler": "^2.9.0",
    "react-native-safe-area-context": "^4.5.0",
    "react-native-screens": "^3.22.0",
    "@react-native-async-storage/async-storage": "^1.20.1",
    "react-native-image-picker": "^5.4.0"
  }
}
```



```javascript
import axios from 'axios';
import AsyncStorage from '@react-native-async-storage/async-storage';

const API = axios.create({ 
  baseURL: 'http://10.0.2.2:4000/api'
});

API.interceptors.request.use(async (config) => {
  const token = await AsyncStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default API;
```



```javascript
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import LoginScreen from '../screens/LoginScreen';
import RegisterScreen from '../screens/RegisterScreen';
import FeedScreen from '../screens/FeedScreen';
import NewPostScreen from '../screens/NewPostScreen';
import ChatScreen from '../screens/ChatScreen';
import ProfileScreen from '../screens/ProfileScreen';
import VIPScreen from '../screens/VIPScreen';

const Stack = createNativeStackNavigator();

export default function RootStack() {
  return (
    <Stack.Navigator initialRouteName="Login">
      <Stack.Screen name="Login" component={LoginScreen} />
      <Stack.Screen name="Register" component={RegisterScreen} />
      <Stack.Screen name="Feed" component={FeedScreen} />
      <Stack.Screen name="NewPost" component={NewPostScreen} />
      <Stack.Screen name="Chat" component={ChatScreen} />
      <Stack.Screen name="Profile" component={ProfileScreen} />
      <Stack.Screen name="VIP" component={VIPScreen} />
    </Stack.Navigator>
  );
}
```


```javascript
import React, { useState } from 'react';
import { View, TextInput, Button, Text, Alert, StyleSheet } from 'react-native';
import API from '../api';
import AsyncStorage from '@react-native-async-storage/async-storage';

export default function LoginScreen({ navigation }) {
  const [phone, setPhone] = useState('');
  const [password, setPassword] = useState('');

  async function login() {
    try {
      const r = await API.post('/auth/login', { phone, password });
      await AsyncStorage.setItem('token', r.data.token);
      navigation.replace('Feed');
    } catch (e) {
      Alert.alert('Erreur', 'Identifiants incorrects');
    }
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ü¶Ö DEO</Text>
      <TextInput 
        placeholder="T√©l√©phone" 
        value={phone} 
        onChangeText={setPhone} 
        style={styles.input} 
      />
      <TextInput 
        placeholder="Mot de passe" 
        value={password} 
        onChangeText={setPassword} 
        secureTextEntry 
        style={styles.input} 
      />
      <Button title="Se connecter" onPress={login} />
      <Button title="S'inscrire" onPress={() => navigation.navigate('Register')} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    justifyContent: 'center', 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
    color: '#ffffff'
  },
  input: { 
    borderWidth: 1, 
    borderColor: '#333',
    backgroundColor: '#2a2a2a',
    color: '#ffffff',
    marginBottom: 12, 
    padding: 12,
    borderRadius: 8
  }
});
```


```javascript
import React, { useState } from 'react';
import { View, TextInput, Button, Text, Alert, StyleSheet } from 'react-native';
import API from '../api';
import AsyncStorage from '@react-native-async-storage/async-storage';

export default function RegisterScreen({ navigation }) {
  const [phone, setPhone] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');

  async function register() {
    try {
      const r = await API.post('/auth/register', { phone, email, password, name });
      await AsyncStorage.setItem('token', r.data.token);
      navigation.replace('Feed');
    } catch (e) {
      Alert.alert('Erreur', e.response?.data?.error || 'Erreur d\'inscription');
    }
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ü¶Ö Cr√©er un compte DEO</Text>
      <TextInput 
        placeholder="Nom" 
        value={name} 
        onChangeText={setName} 
        style={styles.input} 
      />
      <TextInput 
        placeholder="T√©l√©phone" 
        value={phone} 
        onChangeText={setPhone} 
        style={styles.input} 
      />
      <TextInput 
        placeholder="Email" 
        value={email} 
        onChangeText={setEmail} 
        style={styles.input} 
      />
      <TextInput 
        placeholder="Mot de passe" 
        value={password} 
        onChangeText={setPassword} 
        secureTextEntry 
        style={styles.input} 
      />
      <Button title="S'inscrire" onPress={register} />
      <Button title="Se connecter" onPress={() => navigation.navigate('Login')} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    justifyContent: 'center', 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 30,
    color: '#ffffff'
  },
  input: { 
    borderWidth: 1, 
    borderColor: '#333',
    backgroundColor: '#2a2a2a',
    color: '#ffffff',
    marginBottom: 12, 
    padding: 12,
    borderRadius: 8
  }
});
```



```javascript
import React, { useEffect, useState } from 'react';
import { View, FlatList, Text, Button, TouchableOpacity, StyleSheet, Image } from 'react-native';
import API from '../api';

export default function FeedScreen({ navigation }) {
  const [posts, setPosts] = useState([]);

  useEffect(() => { fetchPosts(); }, []);

  async function fetchPosts() {
    try {
      const r = await API.get('/posts');
      setPosts(r.data);
    } catch (e) {
      console.error('Error fetching posts:', e);
    }
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>ü¶Ö Fil DEO</Text>
        <TouchableOpacity 
          style={styles.newPostButton}
          onPress={() => navigation.navigate('NewPost')}
        >
          <Text style={styles.newPostText}>+</Text>
        </TouchableOpacity>
      </View>
      
      <FlatList 
        data={posts} 
        keyExtractor={p => String(p.id)}
        renderItem={({ item }) => (
          <View style={styles.post}>
            <View style={styles.postHeader}>
              <Image 
                source={{ uri: item.avatar_url || 'https://via.placeholder.com/40' }} 
                style={styles.avatar} 
              />
              <Text style={styles.name}>{item.name}</Text>
            </View>
            <Text style={styles.content}>{item.content}</Text>
            {item.image_url && (
              <Image 
                source={{ uri: `http://10.0.2.2:4000${item.image_url}` }} 
                style={styles.postImage} 
              />
            )}
            <View style={styles.postActions}>
              <TouchableOpacity style={styles.actionButton}>
                <Text>‚ù§Ô∏è</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.actionButton}>
                <Text>üí¨</Text>
              </TouchableOpacity>
            </View>
          </View>
        )} 
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#1a1a1a'
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#333'
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#ffffff'
  },
  newPostButton: {
    backgroundColor: '#4a90e2',
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center'
  },
  newPostText: {
    color: '#ffffff',
    fontSize: 20,
    fontWeight: 'bold'
  },
  post: {
    backgroundColor: '#2a2a2a',
    margin: 8,
    padding: 12,
    borderRadius: 8
  },
  postHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8
  },
  avatar: {
    width: 32,
    height: 32,
    borderRadius: 16,
    marginRight: 8
  },
  name: {
    color: '#ffffff',
    fontWeight: 'bold'
  },
  content: {
    color: '#ffffff',
    marginBottom: 8
  },
  postImage: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    marginBottom: 8
  },
  postActions: {
    flexDirection: 'row'
  },
  actionButton: {
    marginRight: 16,
    padding: 4
  }
});
```



```javascript
import React, { useState } from 'react';
import { View, TextInput, Button, Alert, StyleSheet, TouchableOpacity, Text } from 'react-native';
import API from '../api';

export default function NewPostScreen({ navigation }) {
  const [content, setContent] = useState('');

  async function createPost() {
    try {
      const formData = new FormData();
      formData.append('content', content);
      
      await API.post('/posts', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      });
      
      navigation.goBack();
    } catch (e) {
      Alert.alert('Erreur', 'Impossible de cr√©er le post');
    }
  }

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Quoi de neuf ? Partagez en respectant les r√®gles DEO..."
        value={content}
        onChangeText={setContent}
        multiline
        style={styles.input}
        placeholderTextColor="#999"
      />
      <TouchableOpacity style={styles.postButton} onPress={createPost}>
        <Text style={styles.postButtonText}>Publier</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  input: { 
    flex: 1,
    borderWidth: 1, 
    borderColor: '#333',
    backgroundColor: '#2a2a2a',
    color: '#ffffff',
    padding: 12,
    borderRadius: 8,
    textAlignVertical: 'top'
  },
  postButton: {
    backgroundColor: '#4a90e2',
    padding: 16,
    borderRadius: 8,
    marginTop: 16,
    alignItems: 'center'
  },
  postButtonText: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 16
  }
});
```



```javascript
import React, { useEffect, useState } from 'react';
import { View, TextInput, Button, FlatList, Text, StyleSheet } from 'react-native';
import API from '../api';

export default function ChatScreen({ route }) {
  const { userId } = route.params;
  const [conv, setConv] = useState([]);
  const [message, setMessage] = useState('');

  useEffect(() => { load(); }, []);

  async function load() {
    try {
      const r = await API.get(`/messages/conversation/${userId}`);
      setConv(r.data);
    } catch (e) {
      console.error('Error loading messages:', e);
    }
  }

  async function send() {
    try {
      await API.post('/messages/send', { to_user_id: userId, message });
      setMessage('');
      load();
    } catch (e) {
      console.error('Error sending message:', e);
    }
  }

  return (
    <View style={styles.container}>
      <FlatList 
        data={conv} 
        keyExtractor={m => String(m.id)}
        renderItem={({ item }) => (
          <View style={[
            styles.message,
            item.sender_id === userId ? styles.received : styles.sent
          ]}>
            <Text style={styles.messageText}>{item.content}</Text>
          </View>
        )} 
        style={styles.messagesList}
      />
      <View style={styles.inputContainer}>
        <TextInput 
          value={message} 
          onChangeText={setMessage} 
          style={styles.input}
          placeholder="Message..."
          placeholderTextColor="#999"
        />
        <Button title="Envoyer" onPress={send} />
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 10,
    backgroundColor: '#1a1a1a'
  },
  messagesList: {
    flex: 1
  },
  message: {
    padding: 12,
    margin: 4,
    borderRadius: 8,
    maxWidth: '80%'
  },
  sent: {
    alignSelf: 'flex-end',
    backgroundColor: '#4a90e2'
  },
  received: {
    alignSelf: 'flex-start',
    backgroundColor: '#2a2a2a'
  },
  messageText: {
    color: '#ffffff'
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 8
  },
  input: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#333',
    backgroundColor: '#2a2a2a',
    color: '#ffffff',
    padding: 12,
    borderRadius: 8,
    marginRight: 8
  }
});
```



```javascript
import React, { useEffect, useState } from 'react';
import { View, Text, Button, StyleSheet, Image } from 'react-native';
import API from '../api';

export default function ProfileScreen({ navigation }) {
  const [profile, setProfile] = useState(null);

  useEffect(() => { loadProfile(); }, []);

  async function loadProfile() {
    try {
      const r = await API.get('/users/me');
      setProfile(r.data);
    } catch (e) {
      console.error('Error loading profile:', e);
    }
  }

  if (!profile) return <View style={styles.container}><Text>Chargement...</Text></View>;

  return (
    <View style={styles.container}>
      <Image 
        source={{ uri: profile.avatar_url || 'https://via.placeholder.com/100' }} 
        style={styles.avatar} 
      />
      <Text style={styles.name}>{profile.name}</Text>
      <Text style={styles.phone}>{profile.phone}</Text>
      <Text style={styles.bio}>{profile.bio}</Text>
      <Text style={styles.vipStatus}>
        {profile.is_vip ? '‚úÖ Compte VIP' : '‚ùå Compte Standard'}
      </Text>
      <Button 
        title="Devenir VIP" 
        onPress={() => navigation.navigate('VIP')} 
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    alignItems: 'center', 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  avatar: {
    width: 100,
    height: 100,
    borderRadius: 50,
    marginBottom: 16
  },
  name: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 8
  },
  phone: {
    color: '#999',
    marginBottom: 8
  },
  bio: {
    color: '#ffffff',
    textAlign: 'center',
    marginBottom: 16
  },
  vipStatus: {
    color: '#4a90e2',
    marginBottom: 16,
    fontWeight: 'bold'
  }
});
```



```javascript
import React, { useState } from 'react';
import { View, Text, Button, Alert, StyleSheet } from 'react-native';
import API from '../api';

export default function VIPScreen() {
  const [loading, setLoading] = useState(false);

  async function requestVIP() {
    setLoading(true);
    try {
      const r = await API.post('/payments/request', { amount: 5000 });
      Alert.alert('Succ√®s', 'Redirection vers le paiement...');
    } catch (e) {
      Alert.alert('Erreur', 'Impossible de traiter la demande VIP');
    } finally {
      setLoading(false);
    }
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>ü¶Ö Devenir VIP DEO</Text>
      <Text style={styles.description}>
        Profitez d'avantages exclusifs avec le statut VIP
      </Text>
      <Text style={styles.price}>5 000 FCFA / mois</Text>
      <Button 
        title={loading ? "Traitement..." : "Devenir VIP"} 
        onPress={requestVIP} 
        disabled={loading}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    alignItems: 'center', 
    justifyContent: 'center',
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 16
  },
  description: {
    color: '#999',
    textAlign: 'center',
    marginBottom: 24
  },
  price: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#4a90e2',
    marginBottom: 24
  }
});
```


```json
{
  "name": "deo-backend",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js"
  },
  "dependencies": {
    "bcrypt": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.0",
    "express": "^4.18.2",
    "express-rate-limit": "^6.7.0",
    "express-validator": "^6.15.0",
    "helmet": "^6.0.1",
    "jsonwebtoken": "^9.0.0",
    "multer": "^1.4.5-lts.1",
    "pg": "^8.11.0",
    "xss-clean": "^0.1.1",
    "sanitize-filename": "^1.6.3"
  }
}
```



```env
PORT=4000
DATABASE_URL=postgresql://user:password@localhost:5432/deo
JWT_SECRET=deo_super_secret_jwt_key_2024_change_in_production
S3_BUCKET=deo-bucket
AWS_ACCESS_KEY_ID=your_aws_key
AWS_SECRET_ACCESS_KEY=your_aws_secret
AWS_REGION=us-east-1
```



```javascript
require('dotenv').config();
const express = require('express');
const helmet = require('helmet');
const xss = require('xss-clean');
const cors = require('cors');
const fs = require('fs');
const path = require('path');

const pool = require('./db');
const rateLimit = require('./middleware/rateLimit');

const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const postRoutes = require('./routes/posts');
const msgRoutes = require('./routes/messages');
const paymentRoutes = require('./routes/payments');

const app = express();
app.use(helmet());
app.use(xss());
app.use(cors());
app.use(express.json());
app.use(rateLimit);

if (!fs.existsSync('uploads')) fs.mkdirSync('uploads');
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/posts', postRoutes);
app.use('/api/messages', msgRoutes);
app.use('/api/payments', paymentRoutes);

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => console.log(`ü¶Ö DEO backend running on port ${PORT}`));
```



```javascript
const { Pool } = require('pg');
const pool = new Pool({ connectionString: process.env.DATABASE_URL });
module.exports = pool;
```



```javascript
const jwt = require('jsonwebtoken');

module.exports = function(req, res, next) {
  const h = req.headers.authorization;
  if (!h) return res.status(401).json({ error: 'Token manquant' });
  const token = h.split(' ')[1];
  try {
    const data = jwt.verify(token, process.env.JWT_SECRET);
    req.user = data;
    next();
  } catch (e) {
    return res.status(401).json({ error: 'Token invalide' });
  }
};
```



```javascript
const rateLimit = require('express-rate-limit');

module.exports = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 200,
  standardHeaders: true,
  legacyHeaders: false
});
```



```javascript
const multer = require('multer');
const sanitize = require('sanitize-filename');
const path = require('path');

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/');
  },
  filename: function (req, file, cb) {
    const name = Date.now() + '-' + sanitize(file.originalname);
    cb(null, name);
  }
});

const fileFilter = function(req, file, cb){
  const ext = path.extname(file.originalname).toLowerCase();
  if(['.png', '.jpg', '.jpeg', '.webp'].includes(ext)) cb(null, true);
  else cb(new Error('Images uniquement'));
};

module.exports = multer({ storage, fileFilter, limits: { fileSize: 5 * 1024 * 1024 } });
```


```javascript
const bannedWords = [
  'sexe', 'porn', 'nude', 'sexy', 'explicit', 'adult', 'xxx', 'porno',
  'salope', 'connard', 'pute', 'fuck', 'bitch', 'asshole'
];

function containsBanned(text){
  if(!text) return false;
  const t = text.toLowerCase();
  return bannedWords.some(w => t.includes(w));
}

module.exports = function(req, res, next){
  const fieldsToCheck = [];
  if(req.body.content) fieldsToCheck.push(req.body.content);
  if(req.body.message) fieldsToCheck.push(req.body.message);
  if(req.body.name) fieldsToCheck.push(req.body.name);
  if(req.body.bio) fieldsToCheck.push(req.body.bio);

  for(const f of fieldsToCheck){
    if(containsBanned(f)) return res.status(400).json({ error: 'Contenu interdit par les r√®gles DEO' });
  }
  next();
};
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { body, validationResult } = require('express-validator');

router.post('/register',
  body('phone').isLength({ min: 6 }),
  body('password').isLength({ min: 6 }),
  async (req, res) => {
    const errors = validationResult(req);
    if(!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });
    
    const { phone, email, password, name } = req.body;
    const hash = await bcrypt.hash(password, 10);
    
    try{
      const q = `INSERT INTO users(phone,email,password_hash,name) VALUES($1,$2,$3,$4) RETURNING id,phone,email,name,is_vip,avatar_url`;
      const r = await pool.query(q, [phone,email,hash,name]);
      const user = r.rows[0];
      const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '7d' });
      res.json({ token, user });
    }catch(e){
      res.status(400).json({ error: e.message });
    }
  }
);

router.post('/login',
  body('phone').exists(),
  body('password').exists(),
  async (req,res)=>{
    const { phone, password } = req.body;
    const q = `SELECT * FROM users WHERE phone=$1`;
    const r = await pool.query(q, [phone]);
    if(r.rowCount === 0) return res.status(400).json({ error: 'Utilisateur introuvable' });
    
    const user = r.rows[0];
    const ok = await bcrypt.compare(password, user.password_hash);
    if(!ok) return res.status(400).json({ error: 'Mot de passe incorrect' });
    
    const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ 
      token, 
      user: { 
        id: user.id, 
        phone: user.phone, 
        name: user.name, 
        is_vip: user.is_vip, 
        avatar_url: user.avatar_url 
      } 
    });
  }
);

module.exports = router;
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const upload = require('../middleware/upload');
const moderation = require('../middleware/moderation');

router.get('/me', auth, async (req,res)=>{
  const q = `SELECT id,phone,email,name,bio,avatar_url,is_vip,created_at FROM users WHERE id=$1`;
  const r = await pool.query(q, [req.user.id]);
  res.json(r.rows[0]);
});

router.post('/me', auth, upload.single('avatar'), moderation, async (req,res)=>{
  const { name, bio } = req.body;
  const avatar = req.file ? `/uploads/${req.file.filename}` : null;
  const q = `UPDATE users SET name = COALESCE($1, name), bio = COALESCE($2, bio), avatar_url = COALESCE($3, avatar_url) WHERE id=$4 RETURNING id, name, bio, avatar_url, is_vip`;
  const r = await pool.query(q, [name, bio, avatar, req.user.id]);
  res.json(r.rows[0]);
});

module.exports = router;
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const upload = require('../middleware/upload');
const moderation = require('../middleware/moderation');

router.post('/', auth, upload.single('image'), moderation, async (req,res)=>{
  const content = req.body.content || null;
  const image_url = req.file ? `/uploads/${req.file.filename}` : null;
  const q = `INSERT INTO posts(user_id, content, image_url) VALUES($1,$2,$3) RETURNING *`;
  const r = await pool.query(q, [req.user.id, content, image_url]);
  res.json(r.rows[0]);
});

router.get('/', async (req,res)=>{
  const q = `SELECT p.*, u.name, u.avatar_url FROM posts p JOIN users u ON u.id = p.user_id ORDER BY p.created_at DESC LIMIT 100`;
  const r = await pool.query(q);
  res.json(r.rows);
});

router.post('/:id/like', auth, async (req,res)=>{
  const postId = req.params.id;
  try{
    await pool.query(`INSERT INTO likes(user_id, post_id) VALUES($1,$2) ON CONFLICT DO NOTHING`, [req.user.id, postId]);
    res.json({ ok: true });
  }catch(e){ res.status(400).json({ error: e.message }); }
});

module.exports = router;
```


```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const moderation = require('../middleware/moderation');

router.post('/send', auth, moderation, async (req,res)=>{
  const { to_user_id, message } = req.body;
  const q = `INSERT INTO messages(sender_id, receiver_id, content) VALUES($1,$2,$3) RETURNING *`;
  const r = await pool.query(q, [req.user.id, to_user_id, message]);
  res.json(r.rows[0]);
});

router.get('/conversation/:userId', auth, async (req,res)=>{
  const other = req.params.userId;
  const q = `SELECT * FROM messages WHERE (sender_id=$1 AND receiver_id=$2) OR (sender_id=$2 AND receiver_id=$1) ORDER BY created_at ASC`;
  const r = await pool.query(q, [req.user.id, other]);
  res.json(r.rows);
});

module.exports = router;
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');

router.post('/request', auth, async (req,res)=>{
  const { amount } = req.body;
  const q = `INSERT INTO payments(user_id, amount, status) VALUES($1,$2,'PENDING') RETURNING id`;
  const r = await pool.query(q, [req.user.id, amount]);
  res.json({ payment_id: r.rows[0].id, payment_url: `https://example.com/pay/${r.rows[0].id}` });
});

router.post('/webhook', async (req,res)=>{
  const { payment_id, status } = req.body;
  const p = await pool.query(`SELECT user_id FROM payments WHERE id=$1`, [payment_id]);
  if(p.rowCount===0) return res.status(400).end();
  const userId = p.rows[0].user_id;
  
  if(status === 'SUCCESS'){
    await pool.query(`UPDATE users SET is_vip = true WHERE id=$1`, [userId]);
    await pool.query(`UPDATE payments SET status='SUCCESS' WHERE id=$1`, [payment_id]);
  } else {
    await pool.query(`UPDATE payments SET status='FAILED' WHERE id=$1`, [payment_id]);
  }
  res.json({ ok: true });
});

module.exports = router;
```



```sql
-- users
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  phone VARCHAR(50) UNIQUE,
  email VARCHAR(255) UNIQUE,
  password_hash TEXT,
  name VARCHAR(100),
  bio TEXT,
  avatar_url TEXT,
  is_vip BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT now()
);

-- posts
CREATE TABLE posts (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  content TEXT,
  image_url TEXT,
  created_at TIMESTAMP DEFAULT now()
);

-- likes
CREATE TABLE likes (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id),
  post_id INTEGER REFERENCES posts(id),
  created_at TIMESTAMP DEFAULT now(),
  UNIQUE (user_id, post_id)
);

-- follows
CREATE TABLE follows (
  id SERIAL PRIMARY KEY,
  follower_id INTEGER REFERENCES users(id),
  following_id INTEGER REFERENCES users(id),
  created_at TIMESTAMP DEFAULT now(),
  UNIQUE (follower_id, following_id)
);

-- messages
CREATE TABLE messages (
  id SERIAL PRIMARY KEY,
  sender_id INTEGER REFERENCES users(id),
  receiver_id INTEGER REFERENCES users(id),
  content TEXT,
  created_at TIMESTAMP DEFAULT now()
);

-- payments
CREATE TABLE payments (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id),
  amount INTEGER,
  status VARCHAR(20) DEFAULT 'PENDING',
  created_at TIMESTAMP DEFAULT now()
);
```


```javascript
const AWS = require('aws-sdk');

const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
});

async function uploadToS3(fileBuffer, fileName, mimetype) {
  const params = {
    Bucket: process.env.S3_BUCKET,
    Key: `deo/${Date.now()}-${fileName}`,
    Body: fileBuffer,
    ContentType: mimetype,
    ACL: 'public-read'
  };

  try {
    const result = await s3.upload(params).promise();
    return result.Location;
  } catch (error) {
    throw new Error(`S3 upload failed: ${error.message}`);
  }
}

async function deleteFromS3(fileUrl) {
  const key = fileUrl.split('/').pop();
  const params = {
    Bucket: process.env.S3_BUCKET,
    Key: `deo/${key}`
  };

  try {
    await s3.deleteObject(params).promise();
    return true;
  } catch (error) {
    console.error('S3 delete error:', error);
    return false;
  }
}

module.exports = { uploadToS3, deleteFromS3 };
```



```javascript
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransporter({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS
  }
});

async function sendWelcomeEmail(email, name) {
  const mailOptions = {
    from: process.env.EMAIL_USER,
    to: email,
    subject: 'Bienvenue sur DEO ü¶Ö',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #1a1a1a;">Bienvenue sur DEO, ${name} !</h1>
        <p>Votre compte a √©t√© cr√©√© avec succ√®s.</p>
        <p>ü¶Ö <strong>DEO - Le r√©seau social s√©curis√©</strong></p>
        <p>Protection maximale contre le harc√®lement et contenu inappropri√©.</p>
      </div>
    `
  };

  try {
    await transporter.sendMail(mailOptions);
    console.log('Welcome email sent to:', email);
  } catch (error) {
    console.error('Email sending failed:', error);
  }
}

async function sendModerationAlert(email, reason) {
  const mailOptions = {
    from: process.env.EMAIL_USER,
    to: email,
    subject: 'Alerte Mod√©ration DEO ‚ö†Ô∏è',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h1 style="color: #e74c3c;">Alerte de Mod√©ration</h1>
        <p>Votre contenu a √©t√© signal√© pour: <strong>${reason}</strong></p>
        <p>Raison: Violation des r√®gles de la communaut√© DEO</p>
        <p>ü¶Ö <strong>DEO - Tol√©rance Z√©ro</strong></p>
      </div>
    `
  };

  try {
    await transporter.sendMail(mailOptions);
  } catch (error) {
    console.error('Moderation alert email failed:', error);
  }
}

module.exports = { sendWelcomeEmail, sendModerationAlert };
```



```javascript
const AWS = require('aws-sdk');

const rekognition = new AWS.Rekognition();

async function moderateImage(imageBuffer) {
  const params = {
    Image: {
      Bytes: imageBuffer
    },
    MinConfidence: 70
  };

  try {
    const result = await rekognition.detectModerationLabels(params).promise();
    
    const inappropriateLabels = result.ModerationLabels.filter(label => 
      ['Explicit Nudity', 'Violence', 'Visually Disturbing', 'Rude Gestures'].includes(label.Name)
    );

    return {
      isSafe: inappropriateLabels.length === 0,
      labels: inappropriateLabels,
      confidence: inappropriateLabels.length > 0 ? Math.max(...inappropriateLabels.map(l => l.Confidence)) : 0
    };
  } catch (error) {
    console.error('Image moderation error:', error);
    return { isSafe: true, labels: [], confidence: 0 };
  }
}

async function checkForExplicitContent(imageBuffer) {
  const moderation = await moderateImage(imageBuffer);
  
  if (!moderation.isSafe) {
    throw new Error('Image contient du contenu explicite - Supprim√©e pour s√©curit√©');
  }
  
  return true;
}

module.exports = { moderateImage, checkForExplicitContent };
```



```javascript
const jwt = require('jsonwebtoken');

const ADMIN_USERS = ['admin@deo.com', 'moderator@deo.com'];

module.exports = function(req, res, next) {
  const h = req.headers.authorization;
  if (!h) return res.status(401).json({ error: 'Token admin requis' });
  
  const token = h.split(' ')[1];
  try {
    const data = jwt.verify(token, process.env.JWT_SECRET);
    
    if (!ADMIN_USERS.includes(data.email)) {
      return res.status(403).json({ error: 'Acc√®s admin refus√©' });
    }
    
    req.admin = data;
    next();
  } catch (e) {
    return res.status(401).json({ error: 'Token admin invalide' });
  }
};
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const adminAuth = require('../middleware/adminAuth');

router.get('/reports', adminAuth, async (req, res) => {
  try {
    const q = `
      SELECT r.*, u1.name as reporter_name, u2.name as reported_name 
      FROM reports r 
      JOIN users u1 ON r.reporter_id = u1.id 
      JOIN users u2 ON r.reported_user_id = u2.id 
      ORDER BY r.created_at DESC
    `;
    const result = await pool.query(q);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/ban-user', adminAuth, async (req, res) => {
  const { userId, reason } = req.body;
  
  try {
    await pool.query('UPDATE users SET is_banned = true, ban_reason = $1 WHERE id = $2', [reason, userId]);
    res.json({ message: 'Utilisateur banni avec succ√®s' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/stats', adminAuth, async (req, res) => {
  try {
    const usersCount = await pool.query('SELECT COUNT(*) FROM users');
    const postsCount = await pool.query('SELECT COUNT(*) FROM posts');
    const reportsCount = await pool.query('SELECT COUNT(*) FROM reports');
    const vipCount = await pool.query('SELECT COUNT(*) FROM users WHERE is_vip = true');
    
    res.json({
      users: parseInt(usersCount.rows[0].count),
      posts: parseInt(postsCount.rows[0].count),
      reports: parseInt(reportsCount.rows[0].count),
      vipUsers: parseInt(vipCount.rows[0].count)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');

router.post('/report-user', auth, async (req, res) => {
  const { reportedUserId, reason } = req.body;
  
  try {
    const q = `
      INSERT INTO reports (reporter_id, reported_user_id, reason, status) 
      VALUES ($1, $2, $3, 'PENDING') 
      RETURNING *
    `;
    const result = await pool.query(q, [req.user.id, reportedUserId, reason]);
    res.json({ message: 'Signalement envoy√©', report: result.rows[0] });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/report-post', auth, async (req, res) => {
  const { postId, reason } = req.body;
  
  try {
    const q = `
      INSERT INTO post_reports (reporter_id, post_id, reason, status) 
      VALUES ($1, $2, $3, 'PENDING') 
      RETURNING *
    `;
    const result = await pool.query(q, [req.user.id, postId, reason]);
    res.json({ message: 'Post signal√©', report: result.rows[0] });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```


```sql
-- Ajout des tables manquantes
CREATE TABLE IF NOT EXISTS reports (
  id SERIAL PRIMARY KEY,
  reporter_id INTEGER REFERENCES users(id),
  reported_user_id INTEGER REFERENCES users(id),
  reason TEXT NOT NULL,
  status VARCHAR(20) DEFAULT 'PENDING',
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS post_reports (
  id SERIAL PRIMARY KEY,
  reporter_id INTEGER REFERENCES users(id),
  post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,
  reason TEXT NOT NULL,
  status VARCHAR(20) DEFAULT 'PENDING',
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS user_blocks (
  id SERIAL PRIMARY KEY,
  blocker_id INTEGER REFERENCES users(id),
  blocked_id INTEGER REFERENCES users(id),
  created_at TIMESTAMP DEFAULT now(),
  UNIQUE (blocker_id, blocked_id)
);

CREATE TABLE IF NOT EXISTS call_logs (
  id SERIAL PRIMARY KEY,
  caller_id INTEGER REFERENCES users(id),
  receiver_id INTEGER REFERENCES users(id),
  call_type VARCHAR(10) DEFAULT 'audio',
  duration INTEGER DEFAULT 0,
  status VARCHAR(20) DEFAULT 'completed',
  created_at TIMESTAMP DEFAULT now()
);

-- Ajout colonnes manquantes
ALTER TABLE users 
ADD COLUMN IF NOT EXISTS is_banned BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS ban_reason TEXT,
ADD COLUMN IF NOT EXISTS last_login TIMESTAMP,
ADD COLUMN IF NOT EXISTS reputation_score INTEGER DEFAULT 100;

ALTER TABLE posts 
ADD COLUMN IF NOT EXISTS is_flagged BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS flag_reason TEXT;

ALTER TABLE messages 
ADD COLUMN IF NOT EXISTS is_read BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS read_at TIMESTAMP;

-- Index pour les performances
CREATE INDEX IF NOT EXISTS idx_posts_user_id ON posts(user_id);
CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_messages_conversation ON messages(sender_id, receiver_id);
CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_users_phone ON users(phone);
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
```


```javascript
import React, { useState } from 'react';
import { View, TextInput, FlatList, Text, TouchableOpacity, StyleSheet, Image } from 'react-native';
import API from '../api';

export default function SearchScreen({ navigation }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);

  async function searchUsers() {
    if (query.length < 2) {
      setResults([]);
      return;
    }

    try {
      const r = await API.get(`/users/search?q=${query}`);
      setResults(r.data);
    } catch (e) {
      console.error('Search error:', e);
    }
  }

  return (
    <View style={styles.container}>
      <TextInput
        placeholder="Rechercher des utilisateurs..."
        value={query}
        onChangeText={setQuery}
        style={styles.searchInput}
        placeholderTextColor="#999"
        onSubmitEditing={searchUsers}
      />
      
      <FlatList
        data={results}
        keyExtractor={item => String(item.id)}
        renderItem={({ item }) => (
          <TouchableOpacity 
            style={styles.userItem}
            onPress={() => navigation.navigate('Profile', { userId: item.id })}
          >
            <Image 
              source={{ uri: item.avatar_url || 'https://via.placeholder.com/50' }} 
              style={styles.avatar} 
            />
            <View style={styles.userInfo}>
              <Text style={styles.name}>{item.name}</Text>
              <Text style={styles.phone}>{item.phone}</Text>
            </View>
            {item.is_vip && <Text style={styles.vipBadge}>VIP</Text>}
          </TouchableOpacity>
        )}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  searchInput: {
    borderWidth: 1,
    borderColor: '#333',
    backgroundColor: '#2a2a2a',
    color: '#ffffff',
    padding: 12,
    borderRadius: 8,
    marginBottom: 16
  },
  userItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    backgroundColor: '#2a2a2a',
    borderRadius: 8,
    marginBottom: 8
  },
  avatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
    marginRight: 12
  },
  userInfo: {
    flex: 1
  },
  name: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 16
  },
  phone: {
    color: '#999'
  },
  vipBadge: {
    backgroundColor: '#f39c12',
    color: '#000',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    fontSize: 12,
    fontWeight: 'bold'
  }
});
```


```javascript
import React, { useEffect, useState } from 'react';
import { View, FlatList, Text, StyleSheet, TouchableOpacity } from 'react-native';
import API from '../api';

export default function NotificationsScreen({ navigation }) {
  const [notifications, setNotifications] = useState([]);

  useEffect(() => {
    loadNotifications();
  }, []);

  async function loadNotifications() {
    try {
      const r = await API.get('/notifications');
      setNotifications(r.data);
    } catch (e) {
      console.error('Error loading notifications:', e);
    }
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Notifications</Text>
      
      <FlatList
        data={notifications}
        keyExtractor={item => String(item.id)}
        renderItem={({ item }) => (
          <TouchableOpacity style={styles.notification}>
            <Text style={styles.notificationText}>{item.message}</Text>
            <Text style={styles.notificationTime}>
              {new Date(item.created_at).toLocaleDateString()}
            </Text>
          </TouchableOpacity>
        )}
        ListEmptyComponent={
          <Text style={styles.emptyText}>Aucune notification</Text>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 16
  },
  notification: {
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8
  },
  notificationText: {
    color: '#ffffff',
    marginBottom: 4
  },
  notificationTime: {
    color: '#999',
    fontSize: 12
  },
  emptyText: {
    color: '#999',
    textAlign: 'center',
    marginTop: 50
  }
});
```


```javascript
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Alert } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import API from '../api';

export default function SettingsScreen({ navigation }) {
  const handleLogout = async () => {
    Alert.alert(
      'D√©connexion',
      '√ätes-vous s√ªr de vouloir vous d√©connecter ?',
      [
        { text: 'Annuler', style: 'cancel' },
        { 
          text: 'D√©connexion', 
          style: 'destructive',
          onPress: async () => {
            await AsyncStorage.removeItem('token');
            navigation.replace('Login');
          }
        }
      ]
    );
  };

  const handleDeleteAccount = async () => {
    Alert.alert(
      'Supprimer le compte',
      'Cette action est irr√©versible. Supprimer votre compte ?',
      [
        { text: 'Annuler', style: 'cancel' },
        { 
          text: 'Supprimer', 
          style: 'destructive',
          onPress: async () => {
            try {
              await API.delete('/users/me');
              await AsyncStorage.removeItem('token');
              navigation.replace('Login');
            } catch (e) {
              Alert.alert('Erreur', 'Impossible de supprimer le compte');
            }
          }
        }
      ]
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Param√®tres</Text>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>Notifications</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>Confidentialit√©</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>S√©curit√©</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>Aide & Support</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>√Ä propos de DEO</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={[styles.option, styles.logoutOption]} onPress={handleLogout}>
        <Text style={styles.logoutText}>D√©connexion</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={[styles.option, styles.deleteOption]} onPress={handleDeleteAccount}>
        <Text style={styles.deleteText}>Supprimer le compte</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 24
  },
  option: {
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8
  },
  optionText: {
    color: '#ffffff',
    fontSize: 16
  },
  logoutOption: {
    marginTop: 20,
    backgroundColor: '#e74c3c'
  },
  logoutText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center'
  },
  deleteOption: {
    backgroundColor: '#c0392b'
  },
  deleteText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center'
  }
});
```



```javascript
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import LoginScreen from '../screens/LoginScreen';
import RegisterScreen from '../screens/RegisterScreen';
import FeedScreen from '../screens/FeedScreen';
import NewPostScreen from '../screens/NewPostScreen';
import ChatScreen from '../screens/ChatScreen';
import ProfileScreen from '../screens/ProfileScreen';
import VIPScreen from '../screens/VIPScreen';
import SearchScreen from '../screens/SearchScreen';
import NotificationsScreen from '../screens/NotificationsScreen';
import SettingsScreen from '../screens/SettingsScreen';

const Stack = createNativeStackNavigator();
const Tab = createBottomTabNavigator();

function MainTabs() {
  return (
    <Tab.Navigator
      screenOptions={{
        tabBarStyle: { backgroundColor: '#1a1a1a', borderTopColor: '#333' },
        tabBarActiveTintColor: '#4a90e2',
        tabBarInactiveTintColor: '#999'
      }}
    >
      <Tab.Screen name="Feed" component={FeedScreen} options={{ tabBarIcon: () => 'üè†' }} />
      <Tab.Screen name="Search" component={SearchScreen} options={{ tabBarIcon: () => 'üîç' }} />
      <Tab.Screen name="VIP" component={VIPScreen} options={{ tabBarIcon: () => '‚≠ê' }} />
      <Tab.Screen name="Notifications" component={NotificationsScreen} options={{ tabBarIcon: () => 'üîî' }} />
      <Tab.Screen name="Profile" component={ProfileScreen} options={{ tabBarIcon: () => 'üë§' }} />
    </Tab.Navigator>
  );
}

export default function RootStack() {
  return (
    <Stack.Navigator initialRouteName="Login">
      <Stack.Screen name="Login" component={LoginScreen} options={{ headerShown: false }} />
      <Stack.Screen name="Register" component={RegisterScreen} options={{ headerShown: false }} />
      <Stack.Screen name="Main" component={MainTabs} options={{ headerShown: false }} />
      <Stack.Screen name="NewPost" component={NewPostScreen} />
      <Stack.Screen name="Chat" component={ChatScreen} />
      <Stack.Screen name="Settings" component={SettingsScreen} />
    </Stack.Navigator>
  );
}
```



```javascript
// Ajouter apr√®s les autres imports
const adminRoutes = require('./routes/admin');
const reportRoutes = require('./routes/reports');

// Ajouter apr√®s les autres app.use()
app.use('/api/admin', adminRoutes);
app.use('/api/reports', reportRoutes);

// Route de recherche utilisateurs
app.get('/api/users/search', async (req, res) => {
  const { q } = req.query;
  try {
    const result = await pool.query(
      'SELECT id, name, phone, avatar_url, is_vip FROM users WHERE name ILIKE $1 OR phone ILIKE $1 LIMIT 20',
      [`%${q}%`]
    );
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');

router.post('/start', auth, async (req, res) => {
  const { receiver_id, call_type } = req.body;
  
  try {
    const q = `
      INSERT INTO call_logs (caller_id, receiver_id, call_type, status) 
      VALUES ($1, $2, $3, 'initiated') 
      RETURNING *
    `;
    const result = await pool.query(q, [req.user.id, receiver_id, call_type]);
    
    res.json({ 
      call_id: result.rows[0].id,
      message: 'Appel initi√©'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/:callId/accept', auth, async (req, res) => {
  const { callId } = req.params;
  
  try {
    await pool.query(
      'UPDATE call_logs SET status = $1 WHERE id = $2 AND receiver_id = $3',
      ['accepted', callId, req.user.id]
    );
    
    res.json({ message: 'Appel accept√©' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/:callId/end', auth, async (req, res) => {
  const { callId } = req.params;
  const { duration } = req.body;
  
  try {
    await pool.query(
      'UPDATE call_logs SET status = $1, duration = $2 WHERE id = $3',
      ['ended', duration, callId]
    );
    
    res.json({ message: 'Appel termin√©' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/history', auth, async (req, res) => {
  try {
    const q = `
      SELECT cl.*, 
             u1.name as caller_name, 
             u2.name as receiver_name
      FROM call_logs cl
      JOIN users u1 ON cl.caller_id = u1.id
      JOIN users u2 ON cl.receiver_id = u2.id
      WHERE cl.caller_id = $1 OR cl.receiver_id = $1
      ORDER BY cl.created_at DESC
      LIMIT 50
    `;
    const result = await pool.query(q, [req.user.id]);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const upload = require('../middleware/upload');

router.post('/', auth, upload.single('media'), async (req, res) => {
  const { text } = req.body;
  const media_url = req.file ? `/uploads/${req.file.filename}` : null;
  
  try {
    const q = `
      INSERT INTO stories (user_id, text, media_url, expires_at) 
      VALUES ($1, $2, $3, NOW() + INTERVAL '24 hours') 
      RETURNING *
    `;
    const result = await pool.query(q, [req.user.id, text, media_url]);
    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/', auth, async (req, res) => {
  try {
    const q = `
      SELECT s.*, u.name, u.avatar_url 
      FROM stories s 
      JOIN users u ON s.user_id = u.id 
      WHERE s.expires_at > NOW() 
      ORDER BY s.created_at DESC
    `;
    const result = await pool.query(q);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/:storyId/view', auth, async (req, res) => {
  const { storyId } = req.params;
  
  try {
    await pool.query(
      'INSERT INTO story_views (story_id, user_id) VALUES ($1, $2) ON CONFLICT DO NOTHING',
      [storyId, req.user.id]
    );
    
    res.json({ message: 'Story marqu√©e comme vue' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```sql
CREATE TABLE IF NOT EXISTS stories (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  text TEXT,
  media_url TEXT,
  created_at TIMESTAMP DEFAULT now(),
  expires_at TIMESTAMP NOT NULL
);

CREATE TABLE IF NOT EXISTS story_views (
  id SERIAL PRIMARY KEY,
  story_id INTEGER REFERENCES stories(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  viewed_at TIMESTAMP DEFAULT now(),
  UNIQUE(story_id, user_id)
);
```


```javascript
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet, Image } from 'react-native';
import API from '../api';

export default function StoriesScreen({ navigation }) {
  const [stories, setStories] = useState([]);

  useEffect(() => {
    loadStories();
  }, []);

  async function loadStories() {
    try {
      const r = await API.get('/stories');
      setStories(r.data);
    } catch (e) {
      console.error('Error loading stories:', e);
    }
  }

  async function viewStory(storyId) {
    try {
      await API.post(`/stories/${storyId}/view`);
    } catch (e) {
      console.error('Error viewing story:', e);
    }
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Stories DEO</Text>
      
      <FlatList
        data={stories}
        keyExtractor={item => String(item.id)}
        renderItem={({ item }) => (
          <TouchableOpacity 
            style={styles.story}
            onPress={() => {
              viewStory(item.id);
              // Naviguer vers la vue compl√®te du story
            }}
          >
            <Image 
              source={{ uri: item.avatar_url || 'https://via.placeholder.com/60' }} 
              style={styles.avatar} 
            />
            <View style={styles.storyContent}>
              <Text style={styles.userName}>{item.name}</Text>
              {item.text && <Text style={styles.storyText}>{item.text}</Text>}
              {item.media_url && (
                <Image 
                  source={{ uri: `http://10.0.2.2:4000${item.media_url}` }} 
                  style={styles.storyMedia} 
                />
              )}
            </View>
          </TouchableOpacity>
        )}
        ListEmptyComponent={
          <Text style={styles.emptyText}>Aucun story pour le moment</Text>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 16
  },
  story: {
    flexDirection: 'row',
    backgroundColor: '#2a2a2a',
    padding: 12,
    borderRadius: 8,
    marginBottom: 8
  },
  avatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
    marginRight: 12
  },
  storyContent: {
    flex: 1
  },
  userName: {
    color: '#ffffff',
    fontWeight: 'bold',
    marginBottom: 4
  },
  storyText: {
    color: '#ffffff',
    marginBottom: 8
  },
  storyMedia: {
    width: '100%',
    height: 200,
    borderRadius: 8
  },
  emptyText: {
    color: '#999',
    textAlign: 'center',
    marginTop: 50
  }
});
```


```javascript
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, StyleSheet } from 'react-native';
import API from '../api';

export default function CallHistoryScreen() {
  const [calls, setCalls] = useState([]);

  useEffect(() => {
    loadCallHistory();
  }, []);

  async function loadCallHistory() {
    try {
      const r = await API.get('/calls/history');
      setCalls(r.data);
    } catch (e) {
      console.error('Error loading call history:', e);
    }
  }

  const formatDuration = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Historique des appels</Text>
      
      <FlatList
        data={calls}
        keyExtractor={item => String(item.id)}
        renderItem={({ item }) => (
          <View style={styles.callItem}>
            <Text style={styles.callType}>
              {item.call_type === 'video' ? 'üìπ' : 'üìû'} 
              {item.caller_name}
            </Text>
            <Text style={styles.callInfo}>
              {new Date(item.created_at).toLocaleDateString()} ‚Ä¢ 
              {item.duration ? formatDuration(item.duration) : 'Non r√©pondu'}
            </Text>
            <Text style={styles.callStatus}>{item.status}</Text>
          </View>
        )}
        ListEmptyComponent={
          <Text style={styles.emptyText}>Aucun appel</Text>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 16
  },
  callItem: {
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8
  },
  callType: {
    color: '#ffffff',
    fontWeight: 'bold',
    marginBottom: 4
  },
  callInfo: {
    color: '#999',
    marginBottom: 4
  },
  callStatus: {
    color: '#4a90e2'
  },
  emptyText: {
    color: '#999',
    textAlign: 'center',
    marginTop: 50
  }
});
```


```javascript
const pool = require('../db');

async function createNotification(userId, type, message, data = {}) {
  try {
    const q = `
      INSERT INTO notifications (user_id, type, message, data) 
      VALUES ($1, $2, $3, $4) 
      RETURNING *
    `;
    await pool.query(q, [userId, type, message, JSON.stringify(data)]);
  } catch (error) {
    console.error('Notification creation error:', error);
  }
}

async function sendPushNotification(userId, title, body) {
  // Int√©gration avec FCM (Firebase Cloud Messaging)
  // Pour les notifications push mobiles
  console.log(`Push notification to ${userId}: ${title} - ${body}`);
}

module.exports = { 
  createNotification,
  sendPushNotification 
};
```



```sql
CREATE TABLE IF NOT EXISTS notifications (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  type VARCHAR(50) NOT NULL,
  message TEXT NOT NULL,
  data JSONB,
  is_read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_created ON notifications(created_at DESC);
```



```javascript
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Image, Alert } from 'react-native';
import API from '../api';

export default function PostCard({ post, onUpdate }) {
  const [isLiked, setIsLiked] = useState(false);
  const [likeCount, setLikeCount] = useState(post.like_count || 0);

  const handleLike = async () => {
    try {
      await API.post(`/posts/${post.id}/like`);
      setIsLiked(!isLiked);
      setLikeCount(isLiked ? likeCount - 1 : likeCount + 1);
    } catch (e) {
      console.error('Error liking post:', e);
    }
  };

  const handleReport = () => {
    Alert.alert(
      'Signaler',
      'Pourquoi signalez-vous ce post ?',
      [
        { text: 'Contenu inappropri√©', onPress: () => reportPost('inappropriate') },
        { text: 'Harc√®lement', onPress: () => reportPost('harassment') },
        { text: 'Spam', onPress: () => reportPost('spam') },
        { text: 'Annuler', style: 'cancel' }
      ]
    );
  };

  const reportPost = async (reason) => {
    try {
      await API.post('/reports/report-post', { postId: post.id, reason });
      Alert.alert('Succ√®s', 'Post signal√© aux mod√©rateurs');
    } catch (e) {
      Alert.alert('Erreur', 'Impossible de signaler le post');
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Image 
          source={{ uri: post.avatar_url || 'https://via.placeholder.com/40' }} 
          style={styles.avatar} 
        />
        <View style={styles.userInfo}>
          <Text style={styles.name}>{post.name}</Text>
          <Text style={styles.time}>
            {new Date(post.created_at).toLocaleDateString()}
          </Text>
        </View>
        <TouchableOpacity onPress={handleReport}>
          <Text style={styles.reportButton}>‚ö†Ô∏è</Text>
        </TouchableOpacity>
      </View>

      {post.content && (
        <Text style={styles.content}>{post.content}</Text>
      )}

      {post.image_url && (
        <Image 
          source={{ uri: `http://10.0.2.2:4000${post.image_url}` }} 
          style={styles.postImage} 
        />
      )}

      <View style={styles.actions}>
        <TouchableOpacity style={styles.action} onPress={handleLike}>
          <Text style={[styles.actionIcon, isLiked && styles.liked]}>
            {isLiked ? '‚ù§Ô∏è' : 'ü§ç'}
          </Text>
          <Text style={styles.actionCount}>{likeCount}</Text>
        </TouchableOpacity>

        <TouchableOpacity style={styles.action}>
          <Text style={styles.actionIcon}>üí¨</Text>
          <Text style={styles.actionCount}>{post.comment_count || 0}</Text>
        </TouchableOpacity>

        <TouchableOpacity style={styles.action}>
          <Text style={styles.actionIcon}>üîÑ</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#2a2a2a',
    margin: 8,
    padding: 12,
    borderRadius: 8
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8
  },
  avatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    marginRight: 8
  },
  userInfo: {
    flex: 1
  },
  name: {
    color: '#ffffff',
    fontWeight: 'bold'
  },
  time: {
    color: '#999',
    fontSize: 12
  },
  reportButton: {
    fontSize: 16
  },
  content: {
    color: '#ffffff',
    marginBottom: 8,
    lineHeight: 20
  },
  postImage: {
    width: '100%',
    height: 200,
    borderRadius: 8,
    marginBottom: 8
  },
  actions: {
    flexDirection: 'row',
    borderTopWidth: 1,
    borderTopColor: '#333',
    paddingTop: 8
  },
  action: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 16
  },
  actionIcon: {
    fontSize: 18,
    marginRight: 4
  },
  actionCount: {
    color: '#999',
    fontSize: 12
  },
  liked: {
    color: '#e74c3c'
  }
});
```

)

```javascript
import React, { useEffect, useState } from 'react';
import { View, FlatList, TouchableOpacity, StyleSheet, Text } from 'react-native';
import API from '../api';
import PostCard from '../components/PostCard';

export default function FeedScreen({ navigation }) {
  const [posts, setPosts] = useState([]);
  const [refreshing, setRefreshing] = useState(false);

  useEffect(() => { 
    fetchPosts(); 
  }, []);

  async function fetchPosts() {
    try {
      const r = await API.get('/posts');
      setPosts(r.data);
    } catch (e) {
      console.error('Error fetching posts:', e);
    } finally {
      setRefreshing(false);
    }
  }

  const onRefresh = () => {
    setRefreshing(true);
    fetchPosts();
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>ü¶Ö DEO</Text>
        <TouchableOpacity 
          style={styles.newPostButton}
          onPress={() => navigation.navigate('NewPost')}
        >
          <Text style={styles.newPostText}>+</Text>
        </TouchableOpacity>
      </View>
      
      <FlatList 
        data={posts} 
        keyExtractor={p => String(p.id)}
        renderItem={({ item }) => <PostCard post={item} />}
        refreshing={refreshing}
        onRefresh={onRefresh}
        showsVerticalScrollIndicator={false}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#1a1a1a'
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#333'
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff'
  },
  newPostButton: {
    backgroundColor: '#4a90e2',
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center'
  },
  newPostText: {
    color: '#ffffff',
    fontSize: 20,
    fontWeight: 'bold'
  }
});
```



```javascript
const crypto = require('crypto');

const algorithm = 'aes-256-gcm';
const key = crypto.scryptSync(process.env.ENCRYPTION_KEY || 'deo_default_key', 'salt', 32);

function encrypt(text) {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(algorithm, key);
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return {
    content: encrypted,
    iv: iv.toString('hex'),
    authTag: authTag.toString('hex')
  };
}

function decrypt(encryptedData) {
  const decipher = crypto.createDecipher(algorithm, key);
  
  decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
  
  let decrypted = decipher.update(encryptedData.content, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
}

module.exports = { encrypt, decrypt };
```



```javascript
import CryptoJS from 'crypto-js';

const SECRET_KEY = 'deo_mobile_secret_2024';

export const encryptMessage = (message) => {
  return CryptoJS.AES.encrypt(message, SECRET_KEY).toString();
};

export const decryptMessage = (ciphertext) => {
  const bytes = CryptoJS.AES.decrypt(ciphertext, SECRET_KEY);
  return bytes.toString(CryptoJS.enc.Utf8);
};
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const moderation = require('../middleware/moderation');

router.post('/posts/:postId/comments', auth, moderation, async (req, res) => {
  const { postId } = req.params;
  const { content } = req.body;
  
  try {
    const q = `
      INSERT INTO comments (post_id, user_id, content) 
      VALUES ($1, $2, $3) 
      RETURNING *, (SELECT name FROM users WHERE id = $2) as user_name
    `;
    const result = await pool.query(q, [postId, req.user.id, content]);
    
    await pool.query(
      'UPDATE posts SET comment_count = comment_count + 1 WHERE id = $1',
      [postId]
    );
    
    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/posts/:postId/comments', async (req, res) => {
  const { postId } = req.params;
  
  try {
    const q = `
      SELECT c.*, u.name, u.avatar_url 
      FROM comments c 
      JOIN users u ON c.user_id = u.id 
      WHERE c.post_id = $1 
      ORDER BY c.created_at ASC
    `;
    const result = await pool.query(q, [postId]);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.delete('/comments/:commentId', auth, async (req, res) => {
  const { commentId } = req.params;
  
  try {
    const comment = await pool.query(
      'SELECT * FROM comments WHERE id = $1 AND user_id = $2',
      [commentId, req.user.id]
    );
    
    if (comment.rows.length === 0) {
      return res.status(404).json({ error: 'Commentaire non trouv√©' });
    }
    
    await pool.query('DELETE FROM comments WHERE id = $1', [commentId]);
    
    await pool.query(
      'UPDATE posts SET comment_count = comment_count - 1 WHERE id = $1',
      [comment.rows[0].post_id]
    );
    
    res.json({ message: 'Commentaire supprim√©' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```sql
CREATE TABLE IF NOT EXISTS comments (
  id SERIAL PRIMARY KEY,
  post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT now()
);

ALTER TABLE posts ADD COLUMN IF NOT EXISTS comment_count INTEGER DEFAULT 0;
ALTER TABLE posts ADD COLUMN IF NOT EXISTS like_count INTEGER DEFAULT 0;

CREATE INDEX IF NOT EXISTS idx_comments_post ON comments(post_id);
CREATE INDEX IF NOT EXISTS idx_comments_created ON comments(created_at DESC);
```

üì± MOBILE - src/screens/CommentsScreen.js (NOUVEAU)

```javascript
import React, { useEffect, useState } from 'react';
import { View, TextInput, FlatList, Text, TouchableOpacity, StyleSheet, Image } from 'react-native';
import API from '../api';

export default function CommentsScreen({ route, navigation }) {
  const { postId } = route.params;
  const [comments, setComments] = useState([]);
  const [newComment, setNewComment] = useState('');

  useEffect(() => {
    loadComments();
  }, []);

  async function loadComments() {
    try {
      const r = await API.get(`/posts/${postId}/comments`);
      setComments(r.data);
    } catch (e) {
      console.error('Error loading comments:', e);
    }
  }

  async function addComment() {
    if (!newComment.trim()) return;
    
    try {
      const r = await API.post(`/posts/${postId}/comments`, { content: newComment });
      setComments([...comments, r.data]);
      setNewComment('');
    } catch (e) {
      console.error('Error adding comment:', e);
    }
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={comments}
        keyExtractor={item => String(item.id)}
        renderItem={({ item }) => (
          <View style={styles.comment}>
            <Image 
              source={{ uri: item.avatar_url || 'https://via.placeholder.com/40' }} 
              style={styles.avatar} 
            />
            <View style={styles.commentContent}>
              <Text style={styles.userName}>{item.user_name}</Text>
              <Text style={styles.commentText}>{item.content}</Text>
              <Text style={styles.commentTime}>
                {new Date(item.created_at).toLocaleDateString()}
              </Text>
            </View>
          </View>
        )}
        style={styles.commentsList}
      />
      
      <View style={styles.inputContainer}>
        <TextInput
          value={newComment}
          onChangeText={setNewComment}
          placeholder="Ajouter un commentaire..."
          style={styles.input}
          placeholderTextColor="#999"
          multiline
        />
        <TouchableOpacity style={styles.sendButton} onPress={addComment}>
          <Text style={styles.sendText}>üì§</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#1a1a1a'
  },
  commentsList: {
    flex: 1,
    padding: 16
  },
  comment: {
    flexDirection: 'row',
    marginBottom: 16
  },
  avatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    marginRight: 12
  },
  commentContent: {
    flex: 1,
    backgroundColor: '#2a2a2a',
    padding: 12,
    borderRadius: 8
  },
  userName: {
    color: '#4a90e2',
    fontWeight: 'bold',
    marginBottom: 4
  },
  commentText: {
    color: '#ffffff',
    marginBottom: 4
  },
  commentTime: {
    color: '#999',
    fontSize: 12
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: '#333'
  },
  input: {
    flex: 1,
    backgroundColor: '#2a2a2a',
    color: '#ffffff',
    padding: 12,
    borderRadius: 20,
    marginRight: 8
  },
  sendButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#4a90e2',
    justifyContent: 'center',
    alignItems: 'center'
  },
  sendText: {
    color: '#ffffff',
    fontSize: 16
  }
});
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');

router.post('/groups', auth, async (req, res) => {
  const { name, description, is_public } = req.body;
  
  try {
    const q = `
      INSERT INTO groups (name, description, created_by, is_public) 
      VALUES ($1, $2, $3, $4) 
      RETURNING *
    `;
    const result = await pool.query(q, [name, description, req.user.id, is_public]);
    
    await pool.query(
      'INSERT INTO group_members (group_id, user_id, role) VALUES ($1, $2, $3)',
      [result.rows[0].id, req.user.id, 'admin']
    );
    
    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/groups', auth, async (req, res) => {
  try {
    const q = `
      SELECT g.*, 
             (SELECT COUNT(*) FROM group_members WHERE group_id = g.id) as member_count
      FROM groups g
      WHERE g.is_public = true OR EXISTS (
        SELECT 1 FROM group_members WHERE group_id = g.id AND user_id = $1
      )
      ORDER BY g.created_at DESC
    `;
    const result = await pool.query(q, [req.user.id]);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/groups/:groupId/join', auth, async (req, res) => {
  const { groupId } = req.params;
  
  try {
    await pool.query(
      'INSERT INTO group_members (group_id, user_id, role) VALUES ($1, $2, $3) ON CONFLICT DO NOTHING',
      [groupId, req.user.id, 'member']
    );
    
    res.json({ message: 'Rejoint le groupe avec succ√®s' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```sql
CREATE TABLE IF NOT EXISTS groups (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  created_by INTEGER REFERENCES users(id),
  is_public BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS group_members (
  id SERIAL PRIMARY KEY,
  group_id INTEGER REFERENCES groups(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  role VARCHAR(20) DEFAULT 'member',
  joined_at TIMESTAMP DEFAULT now(),
  UNIQUE(group_id, user_id)
);

CREATE TABLE IF NOT EXISTS group_posts (
  id SERIAL PRIMARY KEY,
  group_id INTEGER REFERENCES groups(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  content TEXT,
  image_url TEXT,
  created_at TIMESTAMP DEFAULT now()
);
```



```javascript
import React, { useEffect, useState } from 'react';
import { View, FlatList, Text, TouchableOpacity, StyleSheet, TextInput, Alert } from 'react-native';
import API from '../api';

export default function GroupsScreen({ navigation }) {
  const [groups, setGroups] = useState([]);
  const [showCreate, setShowCreate] = useState(false);
  const [groupName, setGroupName] = useState('');
  const [groupDesc, setGroupDesc] = useState('');

  useEffect(() => {
    loadGroups();
  }, []);

  async function loadGroups() {
    try {
      const r = await API.get('/groups');
      setGroups(r.data);
    } catch (e) {
      console.error('Error loading groups:', e);
    }
  }

  async function createGroup() {
    if (!groupName.trim()) return;
    
    try {
      await API.post('/groups', {
        name: groupName,
        description: groupDesc,
        is_public: true
      });
      
      setGroupName('');
      setGroupDesc('');
      setShowCreate(false);
      loadGroups();
      Alert.alert('Succ√®s', 'Groupe cr√©√© avec succ√®s');
    } catch (e) {
      Alert.alert('Erreur', 'Impossible de cr√©er le groupe');
    }
  }

  async function joinGroup(groupId) {
    try {
      await API.post(`/groups/${groupId}/join`);
      Alert.alert('Succ√®s', 'Vous avez rejoint le groupe');
      loadGroups();
    } catch (e) {
      Alert.alert('Erreur', 'Impossible de rejoindre le groupe');
    }
  }

  return (
    <View style={styles.container}>
      <TouchableOpacity 
        style={styles.createButton}
        onPress={() => setShowCreate(!showCreate)}
      >
        <Text style={styles.createButtonText}>
          {showCreate ? 'Annuler' : 'Cr√©er un groupe'}
        </Text>
      </TouchableOpacity>

      {showCreate && (
        <View style={styles.createForm}>
          <TextInput
            placeholder="Nom du groupe"
            value={groupName}
            onChangeText={setGroupName}
            style={styles.input}
            placeholderTextColor="#999"
          />
          <TextInput
            placeholder="Description"
            value={groupDesc}
            onChangeText={setGroupDesc}
            style={styles.input}
            placeholderTextColor="#999"
            multiline
          />
          <TouchableOpacity style={styles.submitButton} onPress={createGroup}>
            <Text style={styles.submitButtonText}>Cr√©er</Text>
          </TouchableOpacity>
        </View>
      )}

      <FlatList
        data={groups}
        keyExtractor={item => String(item.id)}
        renderItem={({ item }) => (
          <View style={styles.groupItem}>
            <View style={styles.groupInfo}>
              <Text style={styles.groupName}>{item.name}</Text>
              <Text style={styles.groupDesc}>{item.description}</Text>
              <Text style={styles.memberCount}>
                {item.member_count} membres
              </Text>
            </View>
            <TouchableOpacity 
              style={styles.joinButton}
              onPress={() => joinGroup(item.id)}
            >
              <Text style={styles.joinButtonText}>Rejoindre</Text>
            </TouchableOpacity>
          </View>
        )}
        ListEmptyComponent={
          <Text style={styles.emptyText}>Aucun groupe disponible</Text>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  createButton: {
    backgroundColor: '#4a90e2',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginBottom: 16
  },
  createButtonText: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 16
  },
  createForm: {
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    marginBottom: 16
  },
  input: {
    backgroundColor: '#1a1a1a',
    color: '#ffffff',
    padding: 12,
    borderRadius: 8,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#333'
  },
  submitButton: {
    backgroundColor: '#2ecc71',
    padding: 12,
    borderRadius: 8,
    alignItems: 'center'
  },
  submitButtonText: {
    color: '#ffffff',
    fontWeight: 'bold'
  },
  groupItem: {
    flexDirection: 'row',
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8,
    alignItems: 'center'
  },
  groupInfo: {
    flex: 1
  },
  groupName: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 16,
    marginBottom: 4
  },
  groupDesc: {
    color: '#cccccc',
    marginBottom: 4
  },
  memberCount: {
    color: '#999',
    fontSize: 12
  },
  joinButton: {
    backgroundColor: '#4a90e2',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 6
  },
  joinButtonText: {
    color: '#ffffff',
    fontWeight: 'bold'
  },
  emptyText: {
    color: '#999',
    textAlign: 'center',
    marginTop: 50
  }
});
```


```javascript
const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

function createBackup() {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupFile = `backup-deo-${timestamp}.sql`;
  const backupPath = path.join(__dirname, '../backups', backupFile);
  
  const command = `pg_dump ${process.env.DATABASE_URL} > ${backupPath}`;
  
  exec(command, (error, stdout, stderr) => {
    if (error) {
      console.error('Backup error:', error);
      return;
    }
    console.log(`Backup created: ${backupFile}`);
  });
}

function cleanupOldBackups() {
  const backupsDir = path.join(__dirname, '../backups');
  const files = fs.readdirSync(backupsDir);
  
  const now = Date.now();
  const weekAgo = now - (7 * 24 * 60 * 60 * 1000);
  
  files.forEach(file => {
    const filePath = path.join(backupsDir, file);
    const stats = fs.statSync(filePath);
    
    if (stats.mtimeMs < weekAgo) {
      fs.unlinkSync(filePath);
      console.log(`Deleted old backup: ${file}`);
    }
  });
}

module.exports = { createBackup, cleanupOldBackups };
```


```javascript
const rateLimit = require('express-rate-limit');
const helmet = require('helmet');
const pool = require('../db');

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,
  message: 'Trop de tentatives de connexion, veuillez r√©essayer dans 15 minutes'
});

const apiLimiter = rateLimit({
  windowMs: 1 * 60 * 1000,
  max: 100,
  message: 'Trop de requ√™tes, veuillez ralentir'
});

const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  crossOriginEmbedderPolicy: false
});

async function checkAccountLock(userId) {
  const result = await pool.query(
    'SELECT login_attempts, locked_until FROM users WHERE id = $1',
    [userId]
  );
  
  if (result.rows[0].locked_until && result.rows[0].locked_until > new Date()) {
    throw new Error('Compte temporairement verrouill√©');
  }
  
  return true;
}

module.exports = {
  authLimiter,
  apiLimiter,
  securityHeaders,
  checkAccountLock
};
```


```javascript
import { Platform } from 'react-native';
import API from '../api';

export async function registerForPushNotifications() {
  if (Platform.OS === 'web') return;
  
  // Configuration des notifications push
  // √Ä int√©grer avec Firebase Cloud Messaging
  console.log('Registering for push notifications...');
}

export async function sendLocalNotification(title, body) {
  // Pour les notifications locales
  if (Platform.OS === 'ios') {
    // Utiliser react-native-push-notification
  } else {
    // Utiliser react-native-push-notification
  }
}

export async function scheduleNotification(title, body, date) {
  // Planifier une notification
  console.log(`Notification scheduled: ${title} - ${body} at ${date}`);
}
```


```javascript
import React, { useRef, useState } from 'react';
import { View, StyleSheet, TouchableOpacity, Text } from 'react-native';
import { Video } from 'expo-av';

export default function VideoPlayer({ videoUri }) {
  const videoRef = useRef(null);
  const [status, setStatus] = useState({});

  return (
    <View style={styles.container}>
      <Video
        ref={videoRef}
        style={styles.video}
        source={{ uri: videoUri }}
        useNativeControls
        resizeMode="contain"
        isLooping
        onPlaybackStatusUpdate={setStatus}
      />
      
      <View style={styles.controls}>
        <TouchableOpacity
          style={styles.controlButton}
          onPress={() =>
            status.isPlaying 
              ? videoRef.current.pauseAsync() 
              : videoRef.current.playAsync()
          }
        >
          <Text style={styles.controlText}>
            {status.isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'}
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginVertical: 8
  },
  video: {
    width: '100%',
    height: 200,
    borderRadius: 8
  },
  controls: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginTop: 8
  },
  controlButton: {
    padding: 8
  },
  controlText: {
    fontSize: 24
  }
});
```


```javascript
const cron = require('node-cron');
const pool = require('./db');
const { createBackup, cleanupOldBackups } = require('./utils/backup');

// Sauvegarde quotidienne √† 2h du matin
cron.schedule('0 2 * * *', () => {
  console.log('Running daily backup...');
  createBackup();
});

// Nettoyage des stories expir√©s toutes les heures
cron.schedule('0 * * * *', async () => {
  console.log('Cleaning expired stories...');
  await pool.query('DELETE FROM stories WHERE expires_at < NOW()');
});

// Nettoyage des anciennes sauvegardes tous les jours √† 3h
cron.schedule('0 3 * * *', () => {
  console.log('Cleaning old backups...');
  cleanupOldBackups();
});

// Reset des tentatives de connexion tous les jours √† minuit
cron.schedule('0 0 * * *', async () => {
  console.log('Resetting login attempts...');
  await pool.query(`
    UPDATE users 
    SET login_attempts = 0, locked_until = NULL 
    WHERE locked_until < NOW()
  `);
});

module.exports = cron;
```


```json
{
  "expo": {
    "name": "DEO Social",
    "slug": "deo-social",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "dark",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#1a1a1a"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.deo.social",
      "buildNumber": "1"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#1a1a1a"
      },
      "package": "com.deo.social",
      "versionCode": 1
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-notifications"
    ]
  }
}
```

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: deo
      POSTGRES_USER: deo_user
      POSTGRES_PASSWORD: deo_password_secure_2024
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./sql/schema.sql:/docker-entrypoint-initdb.d/schema.sql
    networks:
      - deo-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    networks:
      - deo-network

  backend:
    build: .
    ports:
      - "4000:4000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://deo_user:deo_password_secure_2024@postgres:5432/deo
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=deo_jwt_super_secret_production_2024_change_this
    depends_on:
      - postgres
      - redis
    networks:
      - deo-network
    volumes:
      - ./uploads:/app/uploads
      - ./backups:/app/backups

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - backend
    networks:
      - deo-network

volumes:
  postgres_data:

networks:
  deo-network:
    driver: bridge
```


```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

RUN mkdir -p uploads backups

EXPOSE 4000

USER node

CMD ["node", "index.js"]
```


```nginx
events {
    worker_connections 1024;
}

http {
    upstream backend {
        server backend:4000;
    }

    server {
        listen 80;
        server_name deo-social.com www.deo-social.com;

        # Redirection vers HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name deo-social.com www.deo-social.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;

        # S√©curit√©
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload";

        # Proxy vers le backend
        location /api {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
            
            # Rate limiting
            limit_req zone=api burst=10 nodelay;
        }

        location /uploads {
            proxy_pass http://backend;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # Service des fichiers statiques pour React Native
        location / {
            root /usr/share/nginx/html;
            try_files $uri $uri/ /index.html;
        }
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
}
```



```env
NODE_ENV=production
PORT=4000
DATABASE_URL=postgresql://deo_user:deo_password_secure_2024@postgres:5432/deo
REDIS_URL=redis://redis:6379
JWT_SECRET=deo_jwt_super_secret_production_2024_change_this_in_production
JWT_REFRESH_SECRET=deo_refresh_super_secret_2024_change_this_too

# AWS S3 pour la production
AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
AWS_REGION=us-east-1
S3_BUCKET=deo-production-bucket

# Email SMTP
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=noreply@deo-social.com
EMAIL_PASS=your_app_password

# Mod√©ration IA
CONTENT_MODERATION_API=https://api.moderationservice.com
MODERATION_API_KEY=your_moderation_api_key

# Monitoring
SENTRY_DSN=https://your_sentry_dsn@sentry.io/project
LOG_LEVEL=info

# S√©curit√©
BCRYPT_ROUNDS=12
RATE_LIMIT_WINDOW=900000
RATE_LIMIT_MAX=100
CORS_ORIGIN=https://deo-social.com
```


```env
NODE_ENV=development
PORT=4000
DATABASE_URL=postgresql://postgres:password@localhost:5432/deo
JWT_SECRET=deo_jwt_development_secret_2024
JWT_REFRESH_SECRET=deo_refresh_development_secret_2024

# AWS S3 local
AWS_ACCESS_KEY_ID=test
AWS_SECRET_ACCESS_KEY=test
AWS_REGION=us-east-1
S3_BUCKET=deo-dev-bucket

# Email d√©veloppement
EMAIL_HOST=smtp.ethereal.email
EMAIL_PORT=587
EMAIL_USER=development@deo.com
EMAIL_PASS=development_password

# Mod√©ration d√©veloppement
CONTENT_MODERATION_API=http://localhost:4001
MODERATION_API_KEY=test_key

# Monitoring d√©veloppement
SENTRY_DSN=
LOG_LEVEL=debug

# S√©curit√© d√©veloppement
BCRYPT_ROUNDS=8
RATE_LIMIT_WINDOW=900000
RATE_LIMIT_MAX=1000
CORS_ORIGIN=http://localhost:3000
```



```javascript
module.exports = {
  testEnvironment: 'node',
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    '**/*.js',
    '!**/node_modules/**',
    '!**/coverage/**',
    '!**/jest.config.js'
  ],
  testMatch: [
    '**/__tests__/**/*.js',
    '**/?(*.)+(spec|test).js'
  ],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  testTimeout: 10000
};
```



```javascript
const { Pool } = require('pg');

// Mock pour les tests
jest.mock('./utils/s3', () => ({
  uploadToS3: jest.fn().mockResolvedValue('https://test-bucket.s3.amazonaws.com/test.jpg'),
  deleteFromS3: jest.fn().mockResolvedValue(true)
}));

jest.mock('./utils/emailService', () => ({
  sendWelcomeEmail: jest.fn().mockResolvedValue(true),
  sendModerationAlert: jest.fn().mockResolvedValue(true)
}));

// Base de donn√©es de test
const testPool = new Pool({
  connectionString: process.env.TEST_DATABASE_URL || 'postgresql://test:test@localhost:5432/deo_test'
});

beforeAll(async () => {
  // Cr√©er les tables de test
  await testPool.query(`
    CREATE TABLE IF NOT EXISTS users_test LIKE users;
    CREATE TABLE IF NOT EXISTS posts_test LIKE posts;
    // ... autres tables
  `);
});

afterAll(async () => {
  // Nettoyer apr√®s les tests
  await testPool.query('DROP TABLE IF EXISTS users_test, posts_test, ...');
  await testPool.end();
});

global.testPool = testPool;
```


```javascript
const request = require('supertest');
const app = require('../index');
const pool = require('../db');

describe('Authentication API', () => {
  beforeEach(async () => {
    await pool.query('DELETE FROM users WHERE email LIKE $1', ['%test%']);
  });

  test('POST /api/auth/register - should register new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        phone: '+1234567890',
        email: 'test@deo.com',
        password: 'Password123!',
        name: 'Test User'
      })
      .expect(200);

    expect(response.body).toHaveProperty('token');
    expect(response.body.user).toHaveProperty('id');
    expect(response.body.user.email).toBe('test@deo.com');
  });

  test('POST /api/auth/login - should login user', async () => {
    // D'abord cr√©er un utilisateur
    await request(app)
      .post('/api/auth/register')
      .send({
        phone: '+1234567890',
        email: 'test@deo.com',
        password: 'Password123!',
        name: 'Test User'
      });

    // Puis se connecter
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        phone: '+1234567890',
        password: 'Password123!'
      })
      .expect(200);

    expect(response.body).toHaveProperty('token');
  });

  test('POST /api/auth/login - should reject invalid credentials', async () => {
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        phone: '+1234567890',
        password: 'wrongpassword'
      })
      .expect(400);

    expect(response.body).toHaveProperty('error');
  });
});
```


```javascript
module.exports = {
  apps: [{
    name: 'deo-backend',
    script: './index.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 4000
    },
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_file: './logs/combined.log',
    time: true,
    max_memory_restart: '1G',
    node_args: '--max-old-space-size=1024'
  }],

  deploy: {
    production: {
      user: 'deploy',
      host: ['your-server.com'],
      ref: 'origin/main',
      repo: 'git@github.com:your-org/deo-backend.git',
      path: '/var/www/deo-backend',
      'post-deploy': 'npm install && pm2 reload ecosystem.config.js --env production'
    }
  }
};
```


```javascript
const { getDefaultConfig } = require('expo/metro-config');

const config = getDefaultConfig(__dirname);

config.resolver.assetExts.push(
  'db', // Pour les bases de donn√©es SQLite
  'sqlite'
);

config.transformer = {
  ...config.transformer,
  minifierConfig: {
    keep_classnames: true,
    keep_fnames: true,
    mangle: {
      keep_classnames: true,
      keep_fnames: true,
    },
    compress: {
      reduce_vars: false,
      unused: false,
    },
  },
};

module.exports = config;
```


```javascript
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      [
        'module:react-native-dotenv',
        {
          moduleName: '@env',
          path: '.env',
          blacklist: null,
          whitelist: null,
          safe: false,
          allowUndefined: true,
        },
      ],
      'react-native-reanimated/plugin',
    ],
  };
};
```



```env
# Configuration API
API_BASE_URL=http://localhost:4000/api
WS_BASE_URL=ws://localhost:4000

# Configuration production
# API_BASE_URL=https://api.deo-social.com/api
# WS_BASE_URL=wss://api.deo-social.com

# Services tiers
GOOGLE_WEB_CLIENT_ID=your_google_web_client_id
FACEBOOK_APP_ID=your_facebook_app_id

# Configuration d√©veloppement
DEBUG=true
LOG_LEVEL=debug

# S√©curit√©
ENCRYPTION_KEY=deo_mobile_encryption_key_2024
```


```javascript
import {
  API_BASE_URL,
  WS_BASE_URL,
  DEBUG,
  GOOGLE_WEB_CLIENT_ID,
  FACEBOOK_APP_ID
} from '@env';

export default {
  // API
  API_BASE_URL: API_BASE_URL || 'http://localhost:4000/api',
  WS_BASE_URL: WS_BASE_URL || 'ws://localhost:4000',
  
  // Debug
  DEBUG: DEBUG === 'true',
  LOG_LEVEL: process.env.LOG_LEVEL || 'info',
  
  // OAuth
  GOOGLE_WEB_CLIENT_ID: GOOGLE_WEB_CLIENT_ID || '',
  FACEBOOK_APP_ID: FACEBOOK_APP_ID || '',
  
  // Timeouts
  API_TIMEOUT: 30000,
  UPLOAD_TIMEOUT: 60000,
  
  // Pagination
  POSTS_PER_PAGE: 20,
  MESSAGES_PER_PAGE: 50,
  SEARCH_RESULTS_LIMIT: 100,
  
  // Cache
  CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
  
  // Features
  ENABLE_VIDEO_CALLS: true,
  ENABLE_STORIES: true,
  ENABLE_GROUPS: true,
  
  // Security
  MIN_PASSWORD_LENGTH: 8,
  MAX_UPLOAD_SIZE: 10 * 1024 * 1024, // 10MB
};
```

```javascript
import config from '../config';

class Logger {
  static log(level, message, data = {}) {
    if (!config.DEBUG && level === 'debug') return;
    
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      data,
      platform: Platform.OS,
      version: config.APP_VERSION
    };
    
    console.log(`[${level.toUpperCase()}] ${timestamp}: ${message}`, data);
    
    // En production, envoyer les logs erreur au serveur
    if (level === 'error' && !config.DEBUG) {
      this.sendToServer(logEntry);
    }
  }
  
  static async sendToServer(logEntry) {
    try {
      await fetch(`${config.API_BASE_URL}/logs`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(logEntry)
      });
    } catch (error) {
      console.error('Failed to send log to server:', error);
    }
  }
  
  static debug(message, data) {
    this.log('debug', message, data);
  }
  
  static info(message, data) {
    this.log('info', message, data);
  }
  
  static warn(message, data) {
    this.log('warn', message, data);
  }
  
  static error(message, data) {
    this.log('error', message, data);
  }
}

export default Logger;
```


```bash
#!/bin/bash

set -e

echo "üöÄ Starting DEO deployment..."

# Variables
ENV=${1:-production}
BRANCH=${2:-main}
DOCKER_COMPOSE="docker-compose -f docker-compose.yml -f docker-compose.$ENV.yml"

echo "üì¶ Deploying environment: $ENV"
echo "üåø Branch: $BRANCH"

# Pull latest changes
echo "üì• Pulling latest code..."
git fetch origin
git checkout $BRANCH
git pull origin $BRANCH

# Build and deploy
echo "üê≥ Building Docker images..."
$DOCKER_COMPOSE build

echo "üîÑ Stopping existing services..."
$DOCKER_COMPOSE down

echo "‚ú® Starting services..."
$DOCKER_COMPOSE up -d

# Run migrations
echo "üóÉÔ∏è Running database migrations..."
$DOCKER_COMPOSE exec backend node sql/migrate.js

# Health check
echo "üè• Performing health check..."
sleep 30
curl -f http://localhost:4000/api/health || exit 1

echo "‚úÖ Deployment completed successfully!"
echo "üåê Application is running at: https://deo-social.com"
```



```bash
#!/bin/bash

set -e

# Variables
BACKUP_DIR="/var/backups/deo"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="deo_backup_$TIMESTAMP.sql"

echo "üíæ Starting DEO backup..."

# Create backup directory
mkdir -p $BACKUP_DIR

# Backup database
echo "üì¶ Backing up database..."
pg_dump $DATABASE_URL > $BACKUP_DIR/$BACKUP_FILE

# Compress backup
echo "üóúÔ∏è Compressing backup..."
gzip $BACKUP_DIR/$BACKUP_FILE

# Upload to S3 (optionnel)
if [ -n "$AWS_ACCESS_KEY_ID" ]; then
    echo "‚òÅÔ∏è Uploading to S3..."
    aws s3 cp $BACKUP_DIR/${BACKUP_FILE}.gz s3://deo-backups/
fi

# Cleanup old backups (keep last 7 days)
echo "üßπ Cleaning old backups..."
find $BACKUP_DIR -name "deo_backup_*.sql.gz" -mtime +7 -delete

echo "‚úÖ Backup completed: $BACKUP_DIR/${BACKUP_FILE}.gz"
```



```
deo-project/
‚îú‚îÄ‚îÄ üê≥ docker-compose.yml
‚îú‚îÄ‚îÄ üê≥ Dockerfile
‚îú‚îÄ‚îÄ üöÄ nginx.conf
‚îú‚îÄ‚îÄ ‚öôÔ∏è ecosystem.config.js
‚îú‚îÄ‚îÄ üß™ jest.config.js
‚îú‚îÄ‚îÄ üìã .env.production
‚îú‚îÄ‚îÄ üìã .env.development
‚îú‚îÄ‚îÄ üìÅ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ üöÄ deploy.sh
‚îÇ   ‚îú‚îÄ‚îÄ üíæ backup.sh
‚îÇ   ‚îî‚îÄ‚îÄ üîß migrate.sh
‚îú‚îÄ‚îÄ üìÅ tests/
‚îÇ   ‚îú‚îÄ‚îÄ üß™ setup.js
‚îÇ   ‚îú‚îÄ‚îÄ üîê auth.test.js
‚îÇ   ‚îú‚îÄ‚îÄ üìù posts.test.js
‚îÇ   ‚îî‚îÄ‚îÄ üí¨ messages.test.js
‚îú‚îÄ‚îÄ üìÅ backend/
‚îÇ   ‚îú‚îÄ‚îÄ üóÑÔ∏è package.json
‚îÇ   ‚îú‚îÄ‚îÄ üöÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ üóÉÔ∏è db.js
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ routes/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ utils/
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ sql/
‚îî‚îÄ‚îÄ üìÅ mobile/
    ‚îú‚îÄ‚îÄ üì± package.json
    ‚îú‚îÄ‚îÄ üì± App.js
    ‚îú‚îÄ‚îÄ ‚öôÔ∏è metro.config.js
    ‚îú‚îÄ‚îÄ ‚öôÔ∏è babel.config.js
    ‚îú‚îÄ‚îÄ üìã .env.example
    ‚îú‚îÄ‚îÄ üìÅ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ ‚öôÔ∏è config/
    ‚îÇ   ‚îú‚îÄ‚îÄ üõ†Ô∏è utils/
    ‚îÇ   ‚îú‚îÄ‚îÄ üß≠ navigation/
    ‚îÇ   ‚îú‚îÄ‚îÄ üñºÔ∏è screens/
    ‚îÇ   ‚îú‚îÄ‚îÄ üß© components/
    ‚îÇ   ‚îî‚îÄ‚îÄ üîå api/
    ‚îî‚îÄ‚îÄ üìÅ assets/
        ‚îú‚îÄ‚îÄ üñºÔ∏è icon.png
        ‚îú‚îÄ‚îÄ üñºÔ∏è splash.png
        ‚îî‚îÄ‚îÄ üñºÔ∏è adaptive-icon.png
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const adminAuth = require('../middleware/adminAuth');

router.get('/dashboard', adminAuth, async (req, res) => {
  try {
    // M√©triques principales
    const [
      usersCount,
      activeUsers,
      postsCount,
      engagementRate,
      revenueStats,
      topPosts
    ] = await Promise.all([
      pool.query('SELECT COUNT(*) FROM users'),
      pool.query('SELECT COUNT(*) FROM users WHERE last_login > NOW() - INTERVAL \'7 days\''),
      pool.query('SELECT COUNT(*) FROM posts WHERE created_at > NOW() - INTERVAL \'24 hours\''),
      pool.query(`
        SELECT 
          (COUNT(DISTINCT likes.user_id) + COUNT(DISTINCT comments.user_id)) * 100.0 / 
          GREATEST(COUNT(DISTINCT posts.user_id), 1) as engagement_rate
        FROM posts 
        LEFT JOIN likes ON likes.post_id = posts.id 
        LEFT JOIN comments ON comments.post_id = posts.id 
        WHERE posts.created_at > NOW() - INTERVAL '7 days'
      `),
      pool.query(`
        SELECT 
          SUM(amount) as total_revenue,
          COUNT(*) as vip_count 
        FROM payments 
        WHERE status = 'SUCCESS' 
        AND created_at > NOW() - INTERVAL '30 days'
      `),
      pool.query(`
        SELECT p.*, u.name, 
               COUNT(l.id) as like_count,
               COUNT(c.id) as comment_count
        FROM posts p
        JOIN users u ON p.user_id = u.id
        LEFT JOIN likes l ON l.post_id = p.id
        LEFT JOIN comments c ON c.post_id = p.id
        WHERE p.created_at > NOW() - INTERVAL '7 days'
        GROUP BY p.id, u.name
        ORDER BY (like_count + comment_count) DESC
        LIMIT 10
      `)
    ]);

    res.json({
      metrics: {
        totalUsers: parseInt(usersCount.rows[0].count),
        activeUsers: parseInt(activeUsers.rows[0].count),
        dailyPosts: parseInt(postsCount.rows[0].count),
        engagementRate: parseFloat(engagementRate.rows[0].engagement_rate || 0),
        monthlyRevenue: parseFloat(revenueStats.rows[0].total_revenue || 0),
        vipSubscriptions: parseInt(revenueStats.rows[0].vip_count || 0)
      },
      topPosts: topPosts.rows,
      timestamp: new Date()
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/user-activity/:userId', adminAuth, async (req, res) => {
  const { userId } = req.params;
  
  try {
    const activity = await pool.query(`
      SELECT 
        DATE(created_at) as date,
        COUNT(*) as post_count,
        COUNT(DISTINCT following_id) as follows_given,
        COUNT(DISTINCT follower_id) as follows_received
      FROM posts 
      LEFT JOIN follows ON follows.follower_id = posts.user_id OR follows.following_id = posts.user_id
      WHERE posts.user_id = $1 AND posts.created_at > NOW() - INTERVAL '30 days'
      GROUP BY DATE(created_at)
      ORDER BY date DESC
    `, [userId]);

    res.json(activity.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.get('/content-moderation', adminAuth, async (req, res) => {
  try {
    const moderationStats = await pool.query(`
      SELECT 
        COUNT(*) as total_reports,
        COUNT(CASE WHEN status = 'PENDING' THEN 1 END) as pending_reports,
        COUNT(CASE WHEN status = 'RESOLVED' THEN 1 END) as resolved_reports,
        COUNT(CASE WHEN created_at > NOW() - INTERVAL '24 hours' THEN 1 END) as recent_reports
      FROM reports
    `);

    const topReportedUsers = await pool.query(`
      SELECT u.id, u.name, u.phone, COUNT(r.id) as report_count
      FROM users u
      JOIN reports r ON r.reported_user_id = u.id
      WHERE r.created_at > NOW() - INTERVAL '7 days'
      GROUP BY u.id, u.name, u.phone
      ORDER BY report_count DESC
      LIMIT 10
    `);

    res.json({
      moderation: moderationStats.rows[0],
      topReportedUsers: topReportedUsers.rows
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');

// Syst√®me de recommandation de contenu
router.get('/recommendations/posts', auth, async (req, res) => {
  try {
    const userId = req.user.id;

    // 1. Posts des utilisateurs suivis
    const followedPosts = await pool.query(`
      SELECT p.*, u.name, u.avatar_url
      FROM posts p
      JOIN users u ON p.user_id = u.id
      JOIN follows f ON f.following_id = p.user_id
      WHERE f.follower_id = $1
      AND p.created_at > NOW() - INTERVAL '7 days'
      ORDER BY p.created_at DESC
      LIMIT 20
    `, [userId]);

    // 2. Posts populaires (bas√©s sur les likes et commentaires)
    const popularPosts = await pool.query(`
      SELECT p.*, u.name, u.avatar_url,
             (COUNT(DISTINCT l.id) * 2 + COUNT(DISTINCT c.id)) as engagement_score
      FROM posts p
      JOIN users u ON p.user_id = u.id
      LEFT JOIN likes l ON l.post_id = p.id
      LEFT JOIN comments c ON c.post_id = p.id
      WHERE p.created_at > NOW() - INTERVAL '24 hours'
      AND p.user_id != $1
      AND NOT EXISTS (
        SELECT 1 FROM follows f WHERE f.follower_id = $1 AND f.following_id = p.user_id
      )
      GROUP BY p.id, u.name, u.avatar_url
      HAVING (COUNT(DISTINCT l.id) * 2 + COUNT(DISTINCT c.id)) > 5
      ORDER BY engagement_score DESC
      LIMIT 10
    `, [userId]);

    // 3. Posts bas√©s sur les int√©r√™ts (analyse des likes pass√©s)
    const interestPosts = await pool.query(`
      SELECT DISTINCT p.*, u.name, u.avatar_url
      FROM posts p
      JOIN users u ON p.user_id = u.id
      WHERE p.user_id IN (
        SELECT DISTINCT p2.user_id
        FROM likes l
        JOIN posts p2 ON l.post_id = p2.id
        WHERE l.user_id = $1
        AND p2.created_at > NOW() - INTERVAL '30 days'
      )
      AND p.created_at > NOW() - INTERVAL '3 days'
      AND p.user_id != $1
      AND NOT EXISTS (
        SELECT 1 FROM follows f WHERE f.follower_id = $1 AND f.following_id = p.user_id
      )
      ORDER BY p.created_at DESC
      LIMIT 15
    `, [userId]);

    // Fusionner et d√©dupliquer les r√©sultats
    const allPosts = [...followedPosts.rows, ...popularPosts.rows, ...interestPosts.rows];
    const uniquePosts = allPosts.filter((post, index, self) => 
      index === self.findIndex(p => p.id === post.id)
    );

    // Ordonner par score d'engagement
    uniquePosts.sort((a, b) => {
      const scoreA = (a.like_count || 0) * 2 + (a.comment_count || 0);
      const scoreB = (b.like_count || 0) * 2 + (b.comment_count || 0);
      return scoreB - scoreA;
    });

    res.json(uniquePosts.slice(0, 50));
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Suggestions d'amis intelligentes
router.get('/recommendations/users', auth, async (req, res) => {
  try {
    const userId = req.user.id;

    const suggestions = await pool.query(`
      WITH user_interests AS (
        -- Utilisateurs avec des centres d'int√©r√™t similaires (bas√© sur les likes)
        SELECT DISTINCT l2.user_id, COUNT(*) as common_likes
        FROM likes l1
        JOIN likes l2 ON l1.post_id = l2.post_id
        WHERE l1.user_id = $1
        AND l2.user_id != $1
        AND NOT EXISTS (
          SELECT 1 FROM follows f WHERE f.follower_id = $1 AND f.following_id = l2.user_id
        )
        GROUP BY l2.user_id
        HAVING COUNT(*) > 2
      ),
      location_based AS (
        -- Utilisateurs de la m√™me r√©gion (si disponible)
        SELECT u.id, 1 as score
        FROM users u
        WHERE u.id != $1
        AND u.phone LIKE '%+225%' -- Exemple: utilisateurs de C√¥te d'Ivoire
        AND NOT EXISTS (
          SELECT 1 FROM follows f WHERE f.follower_id = $1 AND f.following_id = u.id
        )
        LIMIT 10
      ),
      popular_users AS (
        -- Utilisateurs populaires avec beaucoup d'abonn√©s
        SELECT u.id, COUNT(f.id) as follower_count
        FROM users u
        LEFT JOIN follows f ON f.following_id = u.id
        WHERE u.id != $1
        AND u.is_vip = true
        AND NOT EXISTS (
          SELECT 1 FROM follows f2 WHERE f2.follower_id = $1 AND f2.following_id = u.id
        )
        GROUP BY u.id
        HAVING COUNT(f.id) > 10
        ORDER BY follower_count DESC
        LIMIT 15
      )
      
      SELECT u.id, u.name, u.avatar_url, u.bio, 
             COALESCE(ui.common_likes, 0) as common_interests,
             'recommended' as reason
      FROM users u
      LEFT JOIN user_interests ui ON ui.user_id = u.id
      WHERE ui.common_likes > 0
      
      UNION
      
      SELECT u.id, u.name, u.avatar_url, u.bio, 0 as common_interests, 'location' as reason
      FROM location_based lb
      JOIN users u ON u.id = lb.id
      
      UNION
      
      SELECT u.id, u.name, u.avatar_url, u.bio, 0 as common_interests, 'popular' as reason
      FROM popular_users pu
      JOIN users u ON u.id = pu.id
      
      ORDER BY common_interests DESC, RANDOM()
      LIMIT 20
    `, [userId]);

    res.json(suggestions.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// D√©tection de contenu trending
router.get('/trending', auth, async (req, res) => {
  try {
    const trending = await pool.query(`
      SELECT 
        p.content,
        p.image_url,
        u.name,
        u.avatar_url,
        COUNT(DISTINCT l.id) as like_count,
        COUNT(DISTINCT c.id) as comment_count,
        COUNT(DISTINCT l.id) + COUNT(DISTINCT c.id) * 2 as trend_score
      FROM posts p
      JOIN users u ON p.user_id = u.id
      LEFT JOIN likes l ON l.post_id = p.id
      LEFT JOIN comments c ON c.post_id = p.id
      WHERE p.created_at > NOW() - INTERVAL '6 hours'
      GROUP BY p.id, p.content, p.image_url, u.name, u.avatar_url
      HAVING COUNT(DISTINCT l.id) + COUNT(DISTINCT c.id) * 2 > 10
      ORDER BY trend_score DESC
      LIMIT 10
    `);

    // Tendances par hashtag (analyse simple du contenu)
    const hashtagTrends = await pool.query(`
      SELECT 
        LOWER(UNNEST(REGEXP_MATCHES(content, '#\\w+', 'g'))) as hashtag,
        COUNT(*) as usage_count
      FROM posts 
      WHERE created_at > NOW() - INTERVAL '24 hours'
      GROUP BY LOWER(UNNEST(REGEXP_MATCHES(content, '#\\w+', 'g')))
      ORDER BY usage_count DESC
      LIMIT 10
    `);

    res.json({
      trendingPosts: trending.rows,
      trendingHashtags: hashtagTrends.rows
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```


```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const { v4: uuidv4 } = require('uuid');

// D√©marrer un live streaming
router.post('/live/start', auth, async (req, res) => {
  const { title, description, is_public = true } = req.body;
  
  try {
    const streamId = uuidv4();
    const streamKey = `deo_live_${req.user.id}_${Date.now()}`;
    
    const q = `
      INSERT INTO live_streams (id, user_id, title, description, stream_key, is_public, status) 
      VALUES ($1, $2, $3, $4, $5, $6, 'starting') 
      RETURNING *
    `;
    
    const result = await pool.query(q, [
      streamId, req.user.id, title, description, streamKey, is_public
    ]);

    res.json({
      stream_id: streamId,
      stream_key: streamKey,
      rtmp_url: `rtmp://live.deo-social.com/live`,
      playback_url: `https://live.deo-social.com/${streamId}/index.m3u8`
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Arr√™ter un live
router.post('/live/:streamId/stop', auth, async (req, res) => {
  const { streamId } = req.params;
  
  try {
    await pool.query(
      'UPDATE live_streams SET status = $1, ended_at = NOW() WHERE id = $2 AND user_id = $3',
      ['ended', streamId, req.user.id]
    );
    
    res.json({ message: 'Live termin√© avec succ√®s' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Liste des lives en cours
router.get('/live/active', auth, async (req, res) => {
  try {
    const lives = await pool.query(`
      SELECT ls.*, u.name, u.avatar_url,
             COUNT(DISTINCT lv.id) as viewer_count
      FROM live_streams ls
      JOIN users u ON ls.user_id = u.id
      LEFT JOIN live_viewers lv ON lv.stream_id = ls.id
      WHERE ls.status = 'live'
      AND (ls.is_public = true OR EXISTS (
        SELECT 1 FROM follows f WHERE f.follower_id = $1 AND f.following_id = ls.user_id
      ))
      GROUP BY ls.id, u.name, u.avatar_url
      ORDER BY viewer_count DESC
    `, [req.user.id]);

    res.json(lives.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Rejoindre un live
router.post('/live/:streamId/join', auth, async (req, res) => {
  const { streamId } = req.params;
  
  try {
    await pool.query(
      `INSERT INTO live_viewers (stream_id, user_id) 
       VALUES ($1, $2) 
       ON CONFLICT (stream_id, user_id) DO UPDATE SET joined_at = NOW()`,
      [streamId, req.user.id]
    );
    
    res.json({ 
      playback_url: `https://live.deo-social.com/${streamId}/index.m3u8`,
      message: 'Vous regardez maintenant le live'
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Envoyer un message dans le chat live
router.post('/live/:streamId/chat', auth, async (req, res) => {
  const { streamId } = req.params;
  const { message } = req.body;
  
  try {
    const q = `
      INSERT INTO live_chat (stream_id, user_id, message) 
      VALUES ($1, $2, $3) 
      RETURNING *, (SELECT name FROM users WHERE id = $2) as user_name
    `;
    
    const result = await pool.query(q, [streamId, req.user.id, message]);
    
    // Diffusion du message via WebSocket
    // (√† impl√©menter avec Socket.IO)
    
    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```


```sql
CREATE TABLE IF NOT EXISTS live_streams (
  id UUID PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(200) NOT NULL,
  description TEXT,
  stream_key VARCHAR(100) UNIQUE NOT NULL,
  is_public BOOLEAN DEFAULT true,
  status VARCHAR(20) DEFAULT 'starting',
  viewer_count INTEGER DEFAULT 0,
  started_at TIMESTAMP DEFAULT now(),
  ended_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS live_viewers (
  id SERIAL PRIMARY KEY,
  stream_id UUID REFERENCES live_streams(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  joined_at TIMESTAMP DEFAULT now(),
  UNIQUE(stream_id, user_id)
);

CREATE TABLE IF NOT EXISTS live_chat (
  id SERIAL PRIMARY KEY,
  stream_id UUID REFERENCES live_streams(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  message TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_live_streams_status ON live_streams(status);
CREATE INDEX IF NOT EXISTS idx_live_streams_user ON live_streams(user_id);
CREATE INDEX IF NOT EXISTS idx_live_viewers_stream ON live_viewers(stream_id);
CREATE INDEX IF NOT EXISTS idx_live_chat_stream ON live_chat(stream_id);
```


```javascript
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, FlatList, TextInput, Alert } from 'react-native';
import { Video } from 'expo-av';
import API from '../api';

export default function LiveStreamScreen({ route, navigation }) {
  const { streamId, isBroadcaster = false } = route.params;
  const [stream, setStream] = useState(null);
  const [chatMessages, setChatMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [viewerCount, setViewerCount] = useState(0);
  const videoRef = useRef(null);

  useEffect(() => {
    loadStream();
    joinStream();
    startChatPolling();
  }, [streamId]);

  async function loadStream() {
    try {
      const r = await API.get(`/live/${streamId}`);
      setStream(r.data);
    } catch (e) {
      Alert.alert('Erreur', 'Stream non disponible');
      navigation.goBack();
    }
  }

  async function joinStream() {
    try {
      await API.post(`/live/${streamId}/join`);
    } catch (e) {
      console.error('Error joining stream:', e);
    }
  }

  function startChatPolling() {
    // Polling pour les nouveaux messages (√† remplacer par WebSocket)
    setInterval(() => {
      loadChatMessages();
      loadViewerCount();
    }, 2000);
  }

  async function loadChatMessages() {
    try {
      const r = await API.get(`/live/${streamId}/chat`);
      setChatMessages(r.data);
    } catch (e) {
      console.error('Error loading chat:', e);
    }
  }

  async function loadViewerCount() {
    try {
      const r = await API.get(`/live/${streamId}/viewers`);
      setViewerCount(r.data.count);
    } catch (e) {
      console.error('Error loading viewer count:', e);
    }
  }

  async function sendMessage() {
    if (!newMessage.trim()) return;

    try {
      await API.post(`/live/${streamId}/chat`, { message: newMessage });
      setNewMessage('');
    } catch (e) {
      Alert.alert('Erreur', 'Impossible d\'envoyer le message');
    }
  }

  async function endStream() {
    Alert.alert(
      'Terminer le live',
      'Voulez-vous vraiment terminer le live ?',
      [
        { text: 'Annuler', style: 'cancel' },
        { 
          text: 'Terminer', 
          style: 'destructive',
          onPress: async () => {
            try {
              await API.post(`/live/${streamId}/stop`);
              navigation.goBack();
            } catch (e) {
              Alert.alert('Erreur', 'Impossible de terminer le live');
            }
          }
        }
      ]
    );
  }

  if (!stream) {
    return (
      <View style={styles.container}>
        <Text style={styles.loadingText}>Chargement du live...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* Lecteur vid√©o */}
      <View style={styles.videoContainer}>
        <Video
          ref={videoRef}
          style={styles.video}
          source={{ uri: stream.playback_url }}
          useNativeControls
          resizeMode="cover"
          shouldPlay
          isLooping
        />
        
        <View style={styles.streamHeader}>
          <Text style={styles.streamTitle}>{stream.title}</Text>
          <Text style={styles.viewerCount}>üëÅÔ∏è {viewerCount} spectateurs</Text>
        </View>

        {isBroadcaster && (
          <TouchableOpacity style={styles.endButton} onPress={endStream}>
            <Text style={styles.endButtonText}>Terminer</Text>
          </TouchableOpacity>
        )}
      </View>

      {/* Chat en direct */}
      <View style={styles.chatContainer}>
        <Text style={styles.chatTitle}>Chat en direct</Text>
        
        <FlatList
          data={chatMessages}
          keyExtractor={item => String(item.id)}
          renderItem={({ item }) => (
            <View style={styles.chatMessage}>
              <Text style={styles.chatUser}>{item.user_name}:</Text>
              <Text style={styles.chatText}>{item.message}</Text>
            </View>
          )}
          style={styles.chatList}
        />

        <View style={styles.chatInputContainer}>
          <TextInput
            value={newMessage}
            onChangeText={setNewMessage}
            placeholder="Envoyer un message..."
            style={styles.chatInput}
            placeholderTextColor="#999"
          />
          <TouchableOpacity style={styles.sendButton} onPress={sendMessage}>
            <Text style={styles.sendButtonText}>üì§</Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#1a1a1a'
  },
  loadingText: {
    color: '#ffffff',
    textAlign: 'center',
    marginTop: 50
  },
  videoContainer: {
    flex: 2,
    position: 'relative'
  },
  video: {
    width: '100%',
    height: '100%'
  },
  streamHeader: {
    position: 'absolute',
    top: 10,
    left: 10,
    right: 10,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center'
  },
  streamTitle: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 16,
    backgroundColor: 'rgba(0,0,0,0.7)',
    padding: 8,
    borderRadius: 8
  },
  viewerCount: {
    color: '#ffffff',
    backgroundColor: 'rgba(0,0,0,0.7)',
    padding: 8,
    borderRadius: 8
  },
  endButton: {
    position: 'absolute',
    bottom: 20,
    right: 20,
    backgroundColor: '#e74c3c',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8
  },
  endButtonText: {
    color: '#ffffff',
    fontWeight: 'bold'
  },
  chatContainer: {
    flex: 1,
    borderTopWidth: 1,
    borderTopColor: '#333'
  },
  chatTitle: {
    color: '#ffffff',
    fontWeight: 'bold',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#333'
  },
  chatList: {
    flex: 1,
    padding: 8
  },
  chatMessage: {
    flexDirection: 'row',
    marginBottom: 8,
    alignItems: 'flex-start'
  },
  chatUser: {
    color: '#4a90e2',
    fontWeight: 'bold',
    marginRight: 4
  },
  chatText: {
    color: '#ffffff',
    flex: 1
  },
  chatInputContainer: {
    flexDirection: 'row',
    padding: 12,
    borderTopWidth: 1,
    borderTopColor: '#333'
  },
  chatInput: {
    flex: 1,
    backgroundColor: '#2a2a2a',
    color: '#ffffff',
    padding: 12,
    borderRadius: 20,
    marginRight: 8
  },
  sendButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#4a90e2',
    justifyContent: 'center',
    alignItems: 'center'
  },
  sendButtonText: {
    color: '#ffffff',
    fontSize: 16
  }
});
```


```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const upload = require('../middleware/upload');

// Publier un produit
router.post('/products', auth, upload.array('images', 5), async (req, res) => {
  const { title, description, price, category, location } = req.body;
  const images = req.files ? req.files.map(f => `/uploads/${f.filename}`) : [];
  
  try {
    const q = `
      INSERT INTO marketplace_products 
      (user_id, title, description, price, category, location, images, status) 
      VALUES ($1, $2, $3, $4, $5, $6, $7, 'active') 
      RETURNING *
    `;
    
    const result = await pool.query(q, [
      req.user.id, title, description, price, category, location, images
    ]);
    
    res.json(result.rows[0]);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Lister les produits
router.get('/products', async (req, res) => {
  const { category, location, min_price, max_price, page = 1 } = req.query;
  const limit = 20;
  const offset = (page - 1) * limit;
  
  try {
    let whereConditions = ['status = $1'];
    let queryParams = ['active'];
    let paramCount = 1;
    
    if (category) {
      paramCount++;
      whereConditions.push(`category = $${paramCount}`);
      queryParams.push(category);
    }
    
    if (location) {
      paramCount++;
      whereConditions.push(`location ILIKE $${paramCount}`);
      queryParams.push(`%${location}%`);
    }
    
    if (min_price) {
      paramCount++;
      whereConditions.push(`price >= $${paramCount}`);
      queryParams.push(min_price);
    }
    
    if (max_price) {
      paramCount++;
      whereConditions.push(`price <= $${paramCount}`);
      queryParams.push(max_price);
    }
    
    const whereClause = whereConditions.length > 0 ? 
      `WHERE ${whereConditions.join(' AND ')}` : '';
    
    const q = `
      SELECT mp.*, u.name as seller_name, u.avatar_url as seller_avatar
      FROM marketplace_products mp
      JOIN users u ON mp.user_id = u.id
      ${whereClause}
      ORDER BY mp.created_at DESC
      LIMIT $${paramCount + 1} OFFSET $${paramCount + 2}
    `;
    
    queryParams.push(limit, offset);
    
    const result = await pool.query(q, queryParams);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Envoyer un message √† un vendeur
router.post('/products/:productId/contact', auth, async (req, res) => {
  const { productId } = req.params;
  const { message } = req.body;
  
  try {
    const product = await pool.query(
      'SELECT user_id FROM marketplace_products WHERE id = $1',
      [productId]
    );
    
    if (product.rows.length === 0) {
      return res.status(404).json({ error: 'Produit non trouv√©' });
    }
    
    const sellerId = product.rows[0].user_id;
    
    // Cr√©er une conversation
    await pool.query(
      `INSERT INTO messages (sender_id, receiver_id, content, type) 
       VALUES ($1, $2, $3, 'marketplace')`,
      [req.user.id, sellerId, `Int√©ress√© par votre produit: ${message}`]
    );
    
    res.json({ message: 'Message envoy√© au vendeur' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```


```sql
CREATE TABLE IF NOT EXISTS marketplace_products (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(200) NOT NULL,
  description TEXT,
  price DECIMAL(10,2) NOT NULL,
  category VARCHAR(50) NOT NULL,
  location VARCHAR(100),
  images TEXT[] DEFAULT '{}',
  status VARCHAR(20) DEFAULT 'active',
  view_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS product_views (
  id SERIAL PRIMARY KEY,
  product_id INTEGER REFERENCES marketplace_products(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  viewed_at TIMESTAMP DEFAULT now(),
  UNIQUE(product_id, user_id)
);

CREATE TABLE IF NOT EXISTS product_favorites (
  id SERIAL PRIMARY KEY,
  product_id INTEGER REFERENCES marketplace_products(id) ON DELETE CASCADE,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP DEFAULT now(),
  UNIQUE(product_id, user_id)
);

CREATE INDEX IF NOT EXISTS idx_marketplace_user ON marketplace_products(user_id);
CREATE INDEX IF NOT EXISTS idx_marketplace_category ON marketplace_products(category);
CREATE INDEX IF NOT EXISTS idx_marketplace_status ON marketplace_products(status);
CREATE INDEX IF NOT EXISTS idx_marketplace_location ON marketplace_products(location);
```


```javascript
import React, { useState, useEffect } from 'react';
import { View, FlatList, Text, TouchableOpacity, StyleSheet, Image, TextInput } from 'react-native';
import API from '../api';

export default function MarketplaceScreen({ navigation }) {
  const [products, setProducts] = useState([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');
  const [categories] = useState([
    'all', 'electronics', 'fashion', 'home', 'vehicles', 'realestate', 'services'
  ]);

  useEffect(() => {
    loadProducts();
  }, [selectedCategory]);

  async function loadProducts() {
    try {
      const params = new URLSearchParams();
      if (selectedCategory !== 'all') params.append('category', selectedCategory);
      
      const r = await API.get(`/marketplace/products?${params}`);
      setProducts(r.data);
    } catch (e) {
      console.error('Error loading products:', e);
    }
  }

  async function searchProducts() {
    try {
      const r = await API.get(`/marketplace/products?search=${searchQuery}`);
      setProducts(r.data);
    } catch (e) {
      console.error('Error searching products:', e);
    }
  }

  function formatPrice(price) {
    return new Intl.NumberFormat('fr-FR', {
      style: 'currency',
      currency: 'XOF'
    }).format(price);
  }

  return (
    <View style={styles.container}>
      {/* Barre de recherche */}
      <View style={styles.searchContainer}>
        <TextInput
          value={searchQuery}
          onChangeText={setSearchQuery}
          placeholder="Rechercher un produit..."
          style={styles.searchInput}
          placeholderTextColor="#999"
          onSubmitEditing={searchProducts}
        />
        <TouchableOpacity style={styles.searchButton} onPress={searchProducts}>
          <Text style={styles.searchButtonText}>üîç</Text>
        </TouchableOpacity>
      </View>

      {/* Cat√©gories */}
      <FlatList
        horizontal
        data={categories}
        keyExtractor={item => item}
        renderItem={({ item }) => (
          <TouchableOpacity 
            style={[
              styles.categoryButton,
              selectedCategory === item && styles.categoryButtonActive
            ]}
            onPress={() => setSelectedCategory(item)}
          >
            <Text style={[
              styles.categoryText,
              selectedCategory === item && styles.categoryTextActive
            ]}>
              {item === 'all' ? 'Tous' : item}
            </Text>
          </TouchableOpacity>
        )}
        style={styles.categoriesList}
        showsHorizontalScrollIndicator={false}
      />

      {/* Liste des produits */}
      <FlatList
        data={products}
        keyExtractor={item => String(item.id)}
        renderItem={({ item }) => (
          <TouchableOpacity 
            style={styles.productCard}
            onPress={() => navigation.navigate('ProductDetail', { productId: item.id })}
          >
            <Image 
              source={{ uri: item.images[0] || 'https://via.placeholder.com/150' }} 
              style={styles.productImage} 
            />
            <View style={styles.productInfo}>
              <Text style={styles.productTitle}>{item.title}</Text>
              <Text style={styles.productPrice}>{formatPrice(item.price)}</Text>
              <Text style={styles.productLocation}>{item.location}</Text>
              <View style={styles.sellerInfo}>
                <Image 
                  source={{ uri: item.seller_avatar || 'https://via.placeholder.com/30' }} 
                  style={styles.sellerAvatar} 
                />
                <Text style={styles.sellerName}>{item.seller_name}</Text>
              </View>
            </View>
          </TouchableOpacity>
        )}
        numColumns={2}
        columnWrapperStyle={styles.productsGrid}
        showsVerticalScrollIndicator={false}
      />

      {/* Bouton pour ajouter un produit */}
      <TouchableOpacity 
        style={styles.addButton}
        onPress={() => navigation.navigate('AddProduct')}
      >
        <Text style={styles.addButtonText}>+</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  searchContainer: {
    flexDirection: 'row',
    marginBottom: 16
  },
  searchInput: {
    flex: 1,
    backgroundColor: '#2a2a2a',
    color: '#ffffff',
    padding: 12,
    borderRadius: 8,
    marginRight: 8
  },
  searchButton: {
    width: 50,
    backgroundColor: '#4a90e2',
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center'
  },
  searchButtonText: {
    color: '#ffffff',
    fontSize: 18
  },
  categoriesList: {
    marginBottom: 16
  },
  categoryButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#2a2a2a',
    borderRadius: 20,
    marginRight: 8
  },
  categoryButtonActive: {
    backgroundColor: '#4a90e2'
  },
  categoryText: {
    color: '#ffffff'
  },
  categoryTextActive: {
    fontWeight: 'bold'
  },
  productsGrid: {
    justifyContent: 'space-between'
  },
  productCard: {
    flex: 0.48,
    backgroundColor: '#2a2a2a',
    borderRadius: 8,
    marginBottom: 16,
    overflow: 'hidden'
  },
  productImage: {
    width: '100%',
    height: 120
  },
  productInfo: {
    padding: 8
  },
  productTitle: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 14,
    marginBottom: 4
  },
  productPrice: {
    color: '#4a90e2',
    fontWeight: 'bold',
    marginBottom: 4
  },
  productLocation: {
    color: '#999',
    fontSize: 12,
    marginBottom: 4
  },
  sellerInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 4
  },
  sellerAvatar: {
    width: 20,
    height: 20,
    borderRadius: 10,
    marginRight: 4
  },
  sellerName: {
    color: '#cccccc',
    fontSize: 12
  },
  addButton: {
    position: 'absolute',
    right: 20,
    bottom: 20,
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: '#4a90e2',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 5
  },
  addButtonText: {
    color: '#ffffff',
    fontSize: 24,
    fontWeight: 'bold'
  }
});
```



```javascript
const supportedLanguages = {
  'fr': { name: 'Fran√ßais', nativeName: 'Fran√ßais', flag: 'üá´üá∑' },
  'en': { name: 'English', nativeName: 'English', flag: 'üá∫üá∏' },
  'es': { name: 'Espa√±ol', nativeName: 'Espa√±ol', flag: 'üá™üá∏' },
  'pt': { name: 'Portugu√™s', nativeName: 'Portugu√™s', flag: 'üáµüáπ' },
  'ar': { name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', nativeName: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', flag: 'üá∏üá¶' },
  'sw': { name: 'Swahili', nativeName: 'Kiswahili', flag: 'üáπüáø' },
  'wo': { name: 'Wolof', nativeName: 'Wolof', flag: 'üá∏üá≥' },
  'bm': { name: 'Bambara', nativeName: 'Bamanankan', flag: 'üá≤üá±' },
  'yo': { name: 'Yoruba', nativeName: 'Yor√πb√°', flag: 'üá≥üá¨' },
  'ig': { name: 'Igbo', nativeName: 'Igbo', flag: 'üá≥üá¨' },
  'ha': { name: 'Hausa', nativeName: 'Hausa', flag: 'üá≥üá¨' },
  'ff': { name: 'Fula', nativeName: 'Fulfulde', flag: 'üá∏üá≥' },
  'am': { name: 'Amharic', nativeName: '·ä†·àõ·à≠·äõ', flag: 'üá™üáπ' },
  'so': { name: 'Somali', nativeName: 'Soomaali', flag: 'üá∏üá¥' }
};

const translations = {
  'fr': {
    // Authentification
    'login': 'Connexion',
    'register': 'Inscription',
    'email': 'Email',
    'phone': 'T√©l√©phone',
    'password': 'Mot de passe',
    'confirm_password': 'Confirmer le mot de passe',
    'forgot_password': 'Mot de passe oubli√©',
    'welcome_back': 'Content de vous revoir',
    'create_account': 'Cr√©er un compte',
    
    // Navigation
    'home': 'Accueil',
    'feed': 'Fil d\'actualit√©',
    'messages': 'Messages',
    'notifications': 'Notifications',
    'profile': 'Profil',
    'search': 'Rechercher',
    'settings': 'Param√®tres',
    
    // Posts
    'whats_new': 'Quoi de neuf ?',
    'post': 'Publier',
    'like': 'J\'aime',
    'comment': 'Commenter',
    'share': 'Partager',
    'delete': 'Supprimer',
    'edit': 'Modifier',
    
    // Messages
    'new_message': 'Nouveau message',
    'type_message': 'Tapez votre message...',
    'send': 'Envoyer',
    'conversations': 'Conversations',
    
    // Profil
    'my_profile': 'Mon profil',
    'edit_profile': 'Modifier le profil',
    'follow': 'Suivre',
    'unfollow': 'Ne plus suivre',
    'followers': 'Abonn√©s',
    'following': 'Abonnements',
    
    // Param√®tres
    'language': 'Langue',
    'privacy': 'Confidentialit√©',
    'security': 'S√©curit√©',
    'notifications_settings': 'Notifications',
    'help': 'Aide',
    'logout': 'D√©connexion',
    
    // Mod√©ration
    'report': 'Signaler',
    'block': 'Bloquer',
    'unblock': 'D√©bloquer',
    'content_violation': 'Violation de contenu',
    
    // VIP
    'vip': 'VIP',
    'premium_features': 'Fonctionnalit√©s premium',
    'subscribe': 'S\'abonner',
    
    // Erreurs
    'error': 'Erreur',
    'success': 'Succ√®s',
    'warning': 'Attention',
    'info': 'Information'
  },
  
  'en': {
    // Authentication
    'login': 'Login',
    'register': 'Register',
    'email': 'Email',
    'phone': 'Phone',
    'password': 'Password',
    'confirm_password': 'Confirm Password',
    'forgot_password': 'Forgot Password',
    'welcome_back': 'Welcome Back',
    'create_account': 'Create Account',
    
    // Navigation
    'home': 'Home',
    'feed': 'Feed',
    'messages': 'Messages',
    'notifications': 'Notifications',
    'profile': 'Profile',
    'search': 'Search',
    'settings': 'Settings',
    
    // Posts
    'whats_new': 'What\'s new?',
    'post': 'Post',
    'like': 'Like',
    'comment': 'Comment',
    'share': 'Share',
    'delete': 'Delete',
    'edit': 'Edit',
    
    // Messages
    'new_message': 'New Message',
    'type_message': 'Type your message...',
    'send': 'Send',
    'conversations': 'Conversations',
    
    // Profile
    'my_profile': 'My Profile',
    'edit_profile': 'Edit Profile',
    'follow': 'Follow',
    'unfollow': 'Unfollow',
    'followers': 'Followers',
    'following': 'Following',
    
    // Settings
    'language': 'Language',
    'privacy': 'Privacy',
    'security': 'Security',
    'notifications_settings': 'Notifications',
    'help': 'Help',
    'logout': 'Logout',
    
    // Moderation
    'report': 'Report',
    'block': 'Block',
    'unblock': 'Unblock',
    'content_violation': 'Content Violation',
    
    // VIP
    'vip': 'VIP',
    'premium_features': 'Premium Features',
    'subscribe': 'Subscribe',
    
    // Errors
    'error': 'Error',
    'success': 'Success',
    'warning': 'Warning',
    'info': 'Information'
  },
  
  'wo': { // Wolof
    'login': 'Dugg',
    'register': 'Diiwaan',
    'email': 'Email',
    'phone': 'Telefoon',
    'password': 'Password',
    'welcome_back': 'Noppi naa la gis',
    'home': 'K√´r',
    'feed': 'Xibaar',
    'messages': 'Bataaxal',
    'profile': 'Profil',
    'whats_new': 'Loo neex?',
    'post': 'T√´ral',
    'like': 'Nopalu',
    'comment': 'Tontu',
    'share': 'Y√≥bbalu'
  },
  
  'bm': { // Bambara
    'login': 'Don s…îr…î',
    'register': 'I t…îg…î s…õb…õn',
    'email': 'Email',
    'phone': 'Telef…îni',
    'password': 'Da…≤…õ',
    'welcome_back': 'I ka k…õn…õ wa',
    'home': 'So',
    'feed': 'Kunnafoni',
    'messages': 'Bataki',
    'profile': 'Profil',
    'whats_new': 'Mun k…õra?',
    'post': 'P…îsti',
    'like': 'N\'ka f…õ',
    'comment': 'Kuma',
    'share': 'B…î'
  },
  
  'sw': { // Swahili
    'login': 'Ingia',
    'register': 'Jisajili',
    'email': 'Barua pepe',
    'phone': 'Simu',
    'password': 'Nenosiri',
    'welcome_back': 'Karibu tena',
    'home': 'Nyumbani',
    'feed': 'Mlolongo',
    'messages': 'Ujumbe',
    'profile': 'Wasifu',
    'whats_new': 'Habari gani?',
    'post': 'Tuma',
    'like': 'Penda',
    'comment': 'Maoni',
    'share': 'Shiriki'
  }
};

function getTranslation(key, language = 'fr') {
  const langTranslations = translations[language] || translations['fr'];
  return langTranslations[key] || key;
}

function detectUserLanguage(acceptLanguageHeader) {
  if (!acceptLanguageHeader) return 'fr';
  
  const languages = acceptLanguageHeader.split(',').map(lang => {
    const [code, quality = 'q=1'] = lang.split(';');
    return {
      code: code.split('-')[0].trim(),
      quality: parseFloat(quality.split('=')[1] || 1)
    };
  });
  
  // Trier par qualit√©
  languages.sort((a, b) => b.quality - a.quality);
  
  // Trouver la premi√®re langue support√©e
  for (const lang of languages) {
    if (supportedLanguages[lang.code]) {
      return lang.code;
    }
  }
  
  return 'fr'; // Fallback vers le fran√ßais
}

function formatNumber(number, language) {
  const formatters = {
    'fr': new Intl.NumberFormat('fr-FR'),
    'en': new Intl.NumberFormat('en-US'),
    'ar': new Intl.NumberFormat('ar-EG'),
    'pt': new Intl.NumberFormat('pt-BR')
  };
  
  const formatter = formatters[language] || formatters['fr'];
  return formatter.format(number);
}

function formatDate(date, language) {
  const formatters = {
    'fr': new Intl.DateTimeFormat('fr-FR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }),
    'en': new Intl.DateTimeFormat('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }),
    'ar': new Intl.DateTimeFormat('ar-EG', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    })
  };
  
  const formatter = formatters[language] || formatters['fr'];
  return formatter.format(new Date(date));
}

module.exports = {
  supportedLanguages,
  translations,
  getTranslation,
  detectUserLanguage,
  formatNumber,
  formatDate
};
```

üóÑÔ∏è BACKEND - middleware/language.js (MIDDLEWARE LANGUE)

```javascript
const { detectUserLanguage, getTranslation } = require('../utils/languages');

function languageMiddleware(req, res, next) {
  // 1. V√©rifier le param√®tre de langue dans l'URL
  let lang = req.query.lang;
  
  // 2. V√©rifier le header Accept-Language
  if (!lang) {
    lang = detectUserLanguage(req.headers['accept-language']);
  }
  
  // 3. V√©rifier si l'utilisateur est connect√© et a une langue pr√©f√©r√©e
  if (req.user && req.user.language) {
    lang = req.user.language;
  }
  
  // 4. Valider que la langue est support√©e
  const supportedLanguages = ['fr', 'en', 'es', 'pt', 'ar', 'sw', 'wo', 'bm', 'yo', 'ig', 'ha', 'ff', 'am', 'so'];
  if (!supportedLanguages.includes(lang)) {
    lang = 'fr'; // Fallback vers le fran√ßais
  }
  
  // Ajouter la langue √† la requ√™te
  req.language = lang;
  
  // M√©thode helper pour les traductions
  req.t = (key, params = {}) => {
    let translation = getTranslation(key, lang);
    
    // Remplacer les param√®tres dynamiques
    Object.keys(params).forEach(param => {
      translation = translation.replace(`{${param}}`, params[param]);
    });
    
    return translation;
  };
  
  next();
}

module.exports = languageMiddleware;
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const { supportedLanguages, getTranslation } = require('../utils/languages');

// Changer la langue de l'utilisateur
router.post('/language', auth, async (req, res) => {
  const { language } = req.body;
  
  try {
    // Valider la langue
    if (!supportedLanguages[language]) {
      return res.status(400).json({ 
        error: req.t('invalid_language') 
      });
    }
    
    // Mettre √† jour la langue de l'utilisateur
    await pool.query(
      'UPDATE users SET language = $1 WHERE id = $2',
      [language, req.user.id]
    );
    
    res.json({ 
      message: req.t('language_updated'),
      language 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Obtenir les langues support√©es
router.get('/languages', (req, res) => {
  res.json({
    languages: supportedLanguages,
    default: 'fr'
  });
});

// Obtenir toutes les traductions pour une langue
router.get('/translations/:language', (req, res) => {
  const { language } = req.params;
  
  if (!supportedLanguages[language]) {
    return res.status(400).json({ error: 'Langue non support√©e' });
  }
  
  res.json({
    language,
    translations: require('../utils/languages').translations[language] || {}
  });
});

// Traduction automatique de texte
router.post('/translate', auth, async (req, res) => {
  const { text, targetLang } = req.body;
  
  try {
    // Service de traduction simple (√† remplacer par Google Translate API)
    const translations = {
      'fr': { 'hello': 'bonjour', 'welcome': 'bienvenue' },
      'en': { 'bonjour': 'hello', 'bienvenue': 'welcome' },
      'wo': { 'hello': 'salaam aleekum', 'welcome': 'd√©gg moo' }
    };
    
    const translatedText = translations[targetLang]?.[text.toLowerCase()] || text;
    
    res.json({
      original: text,
      translated: translatedText,
      targetLang
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```sql
-- Ajouter la colonne langue aux utilisateurs
ALTER TABLE users ADD COLUMN IF NOT EXISTS language VARCHAR(5) DEFAULT 'fr';

-- Table pour les traductions personnalis√©es
CREATE TABLE IF NOT EXISTS custom_translations (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  original_text TEXT NOT NULL,
  translated_text TEXT NOT NULL,
  language VARCHAR(5) NOT NULL,
  context VARCHAR(50),
  created_at TIMESTAMP DEFAULT now()
);

-- Table pour les pr√©f√©rences r√©gionales
CREATE TABLE IF NOT EXISTS regional_settings (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE UNIQUE,
  language VARCHAR(5) DEFAULT 'fr',
  timezone VARCHAR(50) DEFAULT 'UTC',
  currency VARCHAR(3) DEFAULT 'XOF',
  date_format VARCHAR(20) DEFAULT 'DD/MM/YYYY',
  number_format VARCHAR(20) DEFAULT 'fr-FR',
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- Index pour les performances
CREATE INDEX IF NOT EXISTS idx_users_language ON users(language);
CREATE INDEX IF NOT EXISTS idx_custom_translations_user ON custom_translations(user_id, language);
```

üì± MOBILE - src/i18n/index.js (SYST√àME I18N MOBILE)

```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';
import { I18n } from 'i18n-js';

// Import des traductions
import fr from './locales/fr.json';
import en from './locales/en.json';
import wo from './locales/wo.json';
import bm from './locales/bm.json';
import sw from './locales/sw.json';
import yo from './locales/yo.json';
import ig from './locales/ig.json';
import ha from './locales/ha.json';

const i18n = new I18n({
  fr,
  en,
  wo,
  bm,
  sw,
  yo,
  ig,
  ha
});

// Langue par d√©faut
i18n.defaultLocale = 'fr';
i18n.locale = 'fr';
i18n.enableFallback = true;

// Configuration
i18n.missingBehavior = 'guess';
i18n.missingTranslationPrefix = 'üåç ';

// Charger la langue sauvegard√©e
export const loadLanguage = async () => {
  try {
    const savedLanguage = await AsyncStorage.getItem('deo_language');
    if (savedLanguage) {
      i18n.locale = savedLanguage;
    }
    return savedLanguage || 'fr';
  } catch (error) {
    console.error('Error loading language:', error);
    return 'fr';
  }
};

// Changer de langue
export const setLanguage = async (language) => {
  try {
    i18n.locale = language;
    await AsyncStorage.setItem('deo_language', language);
    return true;
  } catch (error) {
    console.error('Error setting language:', error);
    return false;
  }
};

// Obtenir la langue actuelle
export const getCurrentLanguage = () => i18n.locale;

// Formater les nombres selon la locale
export const formatNumber = (number) => {
  return new Intl.NumberFormat(i18n.locale).format(number);
};

// Formater les dates selon la locale
export const formatDate = (date, options = {}) => {
  const defaultOptions = {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  };
  
  return new Date(date).toLocaleDateString(i18n.locale, {
    ...defaultOptions,
    ...options
  });
};

// Formater l'heure relative
export const formatRelativeTime = (date) => {
  const now = new Date();
  const diffInSeconds = Math.floor((now - new Date(date)) / 1000);
  
  if (diffInSeconds < 60) {
    return i18n.t('time.just_now');
  } else if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return i18n.t('time.minutes_ago', { count: minutes });
  } else if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return i18n.t('time.hours_ago', { count: hours });
  } else if (diffInSeconds < 604800) {
    const days = Math.floor(diffInSeconds / 86400);
    return i18n.t('time.days_ago', { count: days });
  } else {
    return formatDate(date);
  }
};

export default i18n;
```



```json
{
  "common": {
    "save": "Sauvegarder",
    "cancel": "Annuler",
    "delete": "Supprimer",
    "edit": "Modifier",
    "confirm": "Confirmer",
    "loading": "Chargement...",
    "error": "Erreur",
    "success": "Succ√®s",
    "warning": "Attention"
  },
  
  "auth": {
    "login": "Connexion",
    "register": "Inscription",
    "email": "Email",
    "phone": "T√©l√©phone",
    "password": "Mot de passe",
    "confirm_password": "Confirmer le mot de passe",
    "forgot_password": "Mot de passe oubli√©",
    "welcome_back": "Content de vous revoir",
    "create_account": "Cr√©er un compte",
    "login_success": "Connexion r√©ussie",
    "register_success": "Compte cr√©√© avec succ√®s"
  },
  
  "navigation": {
    "home": "Accueil",
    "feed": "Fil d'actualit√©",
    "messages": "Messages",
    "notifications": "Notifications",
    "profile": "Profil",
    "search": "Rechercher",
    "settings": "Param√®tres",
    "vip": "VIP"
  },
  
  "posts": {
    "whats_new": "Quoi de neuf ?",
    "post": "Publier",
    "like": "J'aime",
    "comment": "Commenter",
    "share": "Partager",
    "delete_post": "Supprimer le post",
    "edit_post": "Modifier le post",
    "post_success": "Post publi√© avec succ√®s",
    "no_posts": "Aucun post pour le moment",
    "be_first": "Soyez le premier √† publier !"
  },
  
  "messages": {
    "new_message": "Nouveau message",
    "type_message": "Tapez votre message...",
    "send": "Envoyer",
    "conversations": "Conversations",
    "no_messages": "Aucun message",
    "message_sent": "Message envoy√©"
  },
  
  "profile": {
    "my_profile": "Mon profil",
    "edit_profile": "Modifier le profil",
    "follow": "Suivre",
    "unfollow": "Ne plus suivre",
    "followers": "Abonn√©s",
    "following": "Abonnements",
    "posts": "Posts",
    "bio": "Bio",
    "update_success": "Profil mis √† jour"
  },
  
  "settings": {
    "language": "Langue",
    "privacy": "Confidentialit√©",
    "security": "S√©curit√©",
    "notifications": "Notifications",
    "help": "Aide",
    "logout": "D√©connexion",
    "select_language": "Choisir la langue",
    "language_updated": "Langue mise √† jour"
  },
  
  "moderation": {
    "report": "Signaler",
    "block": "Bloquer",
    "unblock": "D√©bloquer",
    "report_content": "Signaler le contenu",
    "report_user": "Signaler l'utilisateur",
    "block_user": "Bloquer l'utilisateur",
    "content_reported": "Contenu signal√©"
  },
  
  "vip": {
    "vip": "VIP",
    "premium_features": "Fonctionnalit√©s premium",
    "subscribe": "S'abonner",
    "monthly": "Mensuel",
    "yearly": "Annuel",
    "benefits": "Avantages VIP"
  },
  
  "time": {
    "just_now": "√Ä l'instant",
    "minutes_ago": "{count} minute | {count} minutes",
    "hours_ago": "{count} heure | {count} heures",
    "days_ago": "{count} jour | {count} jours",
    "weeks_ago": "{count} semaine | {count} semaines"
  },
  
  "errors": {
    "network_error": "Erreur de connexion",
    "server_error": "Erreur du serveur",
    "invalid_credentials": "Identifiants invalides",
    "user_exists": "L'utilisateur existe d√©j√†",
    "weak_password": "Mot de passe trop faible"
  }
}
```



```json
{
  "common": {
    "save": "S√†kku",
    "cancel": "B√†yyi",
    "delete": "Far",
    "edit": "Soppi",
    "confirm": "Jaadu",
    "loading": "M√†bb...",
    "error": "J√†pp",
    "success": "M√†kka",
    "warning": "W√†cc"
  },
  
  "auth": {
    "login": "Dugg",
    "register": "Diiwaan",
    "email": "Email",
    "phone": "Telefoon",
    "password": "Password",
    "confirm_password": "Jaadu Password",
    "forgot_password": "Password b√†mmeel",
    "welcome_back": "Noppi naa la gis",
    "create_account": "Sos Kompt",
    "login_success": "Dugg naa",
    "register_success": "Kompt sos naa"
  },
  
  "navigation": {
    "home": "K√´r",
    "feed": "Xibaar",
    "messages": "Bataaxal",
    "notifications": "Xibaar yu bees",
    "profile": "Profil",
    "search": "Ceet",
    "settings": "Tey",
    "vip": "VIP"
  },
  
  "posts": {
    "whats_new": "Loo neex?",
    "post": "T√´ral",
    "like": "Nopalu",
    "comment": "Tontu",
    "share": "Y√≥bbalu",
    "delete_post": "Far post bi",
    "edit_post": "Soppi post bi",
    "post_success": "Post t√´ral naa",
    "no_posts": "Amul post",
    "be_first": "Yor post bi nj√´kk!"
  },
  
  "messages": {
    "new_message": "Bataaxal bu bees",
    "type_message": "Tapp bataaxal bi...",
    "send": "Y√≥nnee",
    "conversations": "Waxandoo",
    "no_messages": "Amul bataaxal",
    "message_sent": "Bataaxal y√≥nnee naa"
  },
  
  "time": {
    "just_now": "Ci saa si",
    "minutes_ago": "{count} minut | {count} minut",
    "hours_ago": "{count} waxtu | {count} waxtu",
    "days_ago": "{count} b√©s | {count} b√©s",
    "weeks_ago": "{count} ayu-b√©s | {count} ayu-b√©s"
  }
}
```



```json
{
  "common": {
    "save": "S√†nt√®n",
    "cancel": "B…î",
    "delete": "B…î",
    "edit": "S…õg…õs…õg…õ",
    "confirm": "D'√† laÃÅd…în",
    "loading": "B…õ ka don...",
    "error": "F…îl…î",
    "success": "K…õn…õ",
    "warning": "A' k'an ka k…õ"
  },
  
  "auth": {
    "login": "Don s…îr…î",
    "register": "I t…îg…î s…õb…õn",
    "email": "Email",
    "phone": "Telef…îni",
    "password": "Da…≤…õ",
    "confirm_password": "Da…≤…õ jira",
    "forgot_password": "Da…≤…õ oubliy…õ",
    "welcome_back": "I ka k…õn…õ wa",
    "create_account": "Konti k…õ",
    "login_success": "I donnen don",
    "register_success": "Konti k…õra"
  },
  
  "navigation": {
    "home": "So",
    "feed": "Kunnafoni",
    "messages": "Bataki",
    "notifications": "D…înni…≤…õ",
    "profile": "Profil",
    "search": "∆ùini",
    "settings": "Sago",
    "vip": "VIP"
  },
  
  "posts": {
    "whats_new": "Mun k…õra?",
    "post": "P…îsti",
    "like": "N'ka f…õ",
    "comment": "Kuma",
    "share": "B…î",
    "delete_post": "P…îsti b…î",
    "edit_post": "P…îsti s…õg…õs…õg…õ",
    "post_success": "P…îsti k…õra",
    "no_posts": "P…îsti t…õ",
    "be_first": "Aw ye p…îsti k…õ o k…în…î!"
  },
  
  "time": {
    "just_now": "Sisan",
    "minutes_ago": "{count} miniti | {count} miniti",
    "hours_ago": "{count} l…õr…õ | {count} l…õr…õ",
    "days_ago": "{count} don | {count} don",
    "weeks_ago": "{count} d…îg…îkun | {count} d…îg…îkun"
  }
}
```



```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, Modal, StyleSheet, FlatList } from 'react-native';
import i18n, { setLanguage, getCurrentLanguage } from '../i18n';

const languages = {
  'fr': { name: 'Fran√ßais', nativeName: 'Fran√ßais', flag: 'üá´üá∑' },
  'en': { name: 'English', nativeName: 'English', flag: 'üá∫üá∏' },
  'wo': { name: 'Wolof', nativeName: 'Wolof', flag: 'üá∏üá≥' },
  'bm': { name: 'Bambara', nativeName: 'Bamanankan', flag: 'üá≤üá±' },
  'sw': { name: 'Swahili', nativeName: 'Kiswahili', flag: 'üáπüáø' },
  'yo': { name: 'Yoruba', nativeName: 'Yor√πb√°', flag: 'üá≥üá¨' },
  'ig': { name: 'Igbo', nativeName: 'Igbo', flag: 'üá≥üá¨' },
  'ha': { name: 'Hausa', nativeName: 'Hausa', flag: 'üá≥üá¨' }
};

export default function LanguageSelector({ visible, onClose }) {
  const [currentLang, setCurrentLang] = useState('fr');

  useEffect(() => {
    loadCurrentLanguage();
  }, []);

  async function loadCurrentLanguage() {
    const lang = await getCurrentLanguage();
    setCurrentLang(lang);
  }

  async function handleLanguageSelect(languageCode) {
    await setLanguage(languageCode);
    setCurrentLang(languageCode);
    onClose();
  }

  return (
    <Modal
      visible={visible}
      animationType="slide"
      transparent={true}
      onRequestClose={onClose}
    >
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          <Text style={styles.title}>{i18n.t('settings.select_language')}</Text>
          
          <FlatList
            data={Object.entries(languages)}
            keyExtractor={([code]) => code}
            renderItem={({ item: [code, language] }) => (
              <TouchableOpacity
                style={[
                  styles.languageItem,
                  currentLang === code && styles.languageItemSelected
                ]}
                onPress={() => handleLanguageSelect(code)}
              >
                <Text style={styles.flag}>{language.flag}</Text>
                <View style={styles.languageInfo}>
                  <Text style={styles.languageName}>{language.name}</Text>
                  <Text style={styles.nativeName}>{language.nativeName}</Text>
                </View>
                {currentLang === code && (
                  <Text style={styles.selectedIcon}>‚úì</Text>
                )}
              </TouchableOpacity>
            )}
          />
          
          <TouchableOpacity style={styles.closeButton} onPress={onClose}>
            <Text style={styles.closeButtonText}>{i18n.t('common.cancel')}</Text>
          </TouchableOpacity>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  modalContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)'
  },
  modalContent: {
    backgroundColor: '#2a2a2a',
    borderRadius: 12,
    padding: 20,
    width: '90%',
    maxHeight: '80%'
  },
  title: {
    color: '#ffffff',
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center'
  },
  languageItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    borderRadius: 8,
    marginBottom: 8
  },
  languageItemSelected: {
    backgroundColor: '#4a90e2'
  },
  flag: {
    fontSize: 24,
    marginRight: 12
  },
  languageInfo: {
    flex: 1
  },
  languageName: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 16
  },
  nativeName: {
    color: '#cccccc',
    fontSize: 14
  },
  selectedIcon: {
    color: '#ffffff',
    fontSize: 18,
    fontWeight: 'bold'
  },
  closeButton: {
    marginTop: 20,
    padding: 15,
    borderRadius: 8,
    backgroundColor: '#333',
    alignItems: 'center'
  },
  closeButtonText: {
    color: '#ffffff',
    fontWeight: 'bold'
  }
});
```



```javascript
import React, { useState, useEffect } from 'react';
import { View, Text } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { loadLanguage } from './src/i18n';
import RootStack from './src/navigation';

export default function App() {
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    initializeApp();
  }, []);

  async function initializeApp() {
    try {
      // Charger la langue sauvegard√©e
      await loadLanguage();
    } catch (error) {
      console.error('App initialization error:', error);
    } finally {
      setIsLoading(false);
    }
  }

  if (isLoading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1a1a1a' }}>
        <Text style={{ color: '#ffffff' }}>ü¶Ö DEO</Text>
        <Text style={{ color: '#999', marginTop: 10 }}>Chargement...</Text>
      </View>
    );
  }

  return (
    <NavigationContainer>
      <RootStack />
    </NavigationContainer>
  );
}
```


```javascript
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Alert } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import API from '../api';
import i18n, { getCurrentLanguage } from '../i18n';
import LanguageSelector from '../components/LanguageSelector';

export default function SettingsScreen({ navigation }) {
  const [showLanguageSelector, setShowLanguageSelector] = useState(false);
  const [currentLanguage, setCurrentLanguage] = useState('fr');

  React.useEffect(() => {
    loadCurrentLanguage();
  }, []);

  async function loadCurrentLanguage() {
    const lang = await getCurrentLanguage();
    setCurrentLanguage(lang);
  }

  const handleLogout = async () => {
    Alert.alert(
      i18n.t('common.confirm'),
      i18n.t('settings.logout_confirm'),
      [
        { text: i18n.t('common.cancel'), style: 'cancel' },
        { 
          text: i18n.t('settings.logout'), 
          style: 'destructive',
          onPress: async () => {
            await AsyncStorage.removeItem('token');
            navigation.replace('Login');
          }
        }
      ]
    );
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>{i18n.t('settings.settings')}</Text>
      
      {/* S√©lecteur de langue */}
      <TouchableOpacity 
        style={styles.option}
        onPress={() => setShowLanguageSelector(true)}
      >
        <Text style={styles.optionText}>{i18n.t('settings.language')}</Text>
        <Text style={styles.optionValue}>
          {currentLanguage.toUpperCase()} {i18n.t('settings.current_language')}
        </Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>{i18n.t('settings.privacy')}</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>{i18n.t('settings.security')}</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>{i18n.t('settings.notifications')}</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={styles.option}>
        <Text style={styles.optionText}>{i18n.t('settings.help')}</Text>
      </TouchableOpacity>
      
      <TouchableOpacity style={[styles.option, styles.logoutOption]} onPress={handleLogout}>
        <Text style={styles.logoutText}>{i18n.t('settings.logout')}</Text>
      </TouchableOpacity>

      {/* S√©lecteur de langue modal */}
      <LanguageSelector
        visible={showLanguageSelector}
        onClose={() => {
          setShowLanguageSelector(false);
          loadCurrentLanguage(); // Recharger la langue actuelle
        }}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 24
  },
  option: {
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center'
  },
  optionText: {
    color: '#ffffff',
    fontSize: 16
  },
  optionValue: {
    color: '#999',
    fontSize: 14
  },
  logoutOption: {
    marginTop: 20,
    backgroundColor: '#e74c3c'
  },
  logoutText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: 'bold',
    textAlign: 'center'
  }
});
```


```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const axios = require('axios');

// Service de mod√©ration IA avanc√©e
class AdvancedModeration {
  static async analyzeText(text) {
    try {
      // Int√©gration avec OpenAI Moderation API
      const response = await axios.post('https://api.openai.com/v1/moderations', {
        input: text
      }, {
        headers: {
          'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        }
      });

      const result = response.data.results[0];
      
      return {
        isSafe: !result.flagged,
        categories: result.categories,
        scores: result.category_scores,
        flagged: result.flagged
      };
    } catch (error) {
      // Fallback vers la mod√©ration basique
      return this.basicTextAnalysis(text);
    }
  }

  static async analyzeImage(imageUrl) {
    try {
      // Int√©gration avec Google Vision AI
      const response = await axios.post(
        `https://vision.googleapis.com/v1/images:annotate?key=${process.env.GOOGLE_VISION_API_KEY}`,
        {
          requests: [
            {
              image: { source: { imageUri: imageUrl } },
              features: [
                { type: 'SAFE_SEARCH_DETECTION' },
                { type: 'LABEL_DETECTION' },
                { type: 'EXPLICIT_CONTENT_DETECTION' }
              ]
            }
          ]
        }
      );

      const safeSearch = response.data.responses[0].safeSearchAnnotation;
      const labels = response.data.responses[0].labelAnnotations;
      
      return {
        isSafe: safeSearch.adult === 'VERY_UNLIKELY' && 
                safeSearch.violence === 'VERY_UNLIKELY' &&
                safeSearch.racy === 'VERY_UNLIKELY',
        safeSearch: safeSearch,
        labels: labels.map(label => label.description)
      };
    } catch (error) {
      console.error('Image moderation error:', error);
      return { isSafe: true, safeSearch: {}, labels: [] };
    }
  }

  static basicTextAnalysis(text) {
    const forbiddenPatterns = [
      // Contenu sexuel explicite
      /sexe?|porn|nude|sexy?|explicit|adult|xxx|porno|nudit√©|seins|fesses/gi,
      // Insultes et harc√®lement
      /salope|connard|pute|fuck|bitch|asshole|idiot|stupide|d√©bile|imb√©cile/gi,
      // Discours haineux
      /haine|racist|nazi|fascist|supremacist|discrimination|islamophobi|antis√©mit/gi,
      // Menaces et violence
      /kill|murder|death|threat|menace|violence|attack|bomb|weapon|arme/gi,
      // Spam et fraude
      /bitcoin|crypto|investissement|profit|gagner.argent|rich|million/gi
    ];

    const flags = [];
    let score = 0;

    forbiddenPatterns.forEach((pattern, index) => {
      const matches = text.match(pattern);
      if (matches) {
        flags.push(`pattern_${index}`);
        score += matches.length * 0.1;
      }
    });

    return {
      isSafe: score < 0.6,
      score: Math.min(score, 1.0),
      flags: flags,
      flagged: score >= 0.6
    };
  }
}

// Mod√©ration en temps r√©el des posts
router.post('/moderate/post', auth, async (req, res) => {
  const { content, imageUrl } = req.body;
  
  try {
    let textResult = { isSafe: true, score: 0, flags: [] };
    let imageResult = { isSafe: true, safeSearch: {}, labels: [] };

    // Analyser le texte
    if (content) {
      textResult = await AdvancedModeration.analyzeText(content);
    }

    // Analyser l'image
    if (imageUrl) {
      imageResult = await AdvancedModeration.analyzeImage(imageUrl);
    }

    const overallSafe = textResult.isSafe && imageResult.isSafe;
    const overallScore = Math.max(textResult.score, imageResult.isSafe ? 0 : 0.8);

    // Journaliser la mod√©ration
    await pool.query(
      `INSERT INTO moderation_logs 
       (user_id, content_type, content, risk_score, flags, action_taken) 
       VALUES ($1, $2, $3, $4, $5, $6)`,
      [
        req.user.id,
        'post',
        content,
        overallScore,
        [...textResult.flags, ...imageResult.labels],
        overallSafe ? 'allowed' : 'blocked'
      ]
    );

    // Appliquer des sanctions si n√©cessaire
    if (!overallSafe) {
      await applyModerationSanctions(req.user.id, overallScore);
    }

    res.json({
      isSafe: overallSafe,
      riskScore: overallScore,
      textAnalysis: textResult,
      imageAnalysis: imageResult,
      action: overallSafe ? 'allow' : 'block'
    });

  } catch (error) {
    console.error('Moderation error:', error);
    res.status(500).json({ error: 'Erreur de mod√©ration' });
  }
});

async function applyModerationSanctions(userId, riskScore) {
  // R√©duire la r√©putation
  const reputationDeduction = Math.floor(riskScore * 50);
  await pool.query(
    'UPDATE users SET reputation_score = GREATEST(0, reputation_score - $1) WHERE id = $2',
    [reputationDeduction, userId]
  );

  // Bannissement temporaire pour les violations graves
  if (riskScore > 0.8) {
    const banHours = Math.floor(riskScore * 24);
    await pool.query(
      `INSERT INTO user_bans (user_id, reason, duration_hours, banned_by) 
       VALUES ($1, $2, $3, $4)`,
      [userId, 'Content moderation violation', banHours, 'system']
    );
  }
}

module.exports = router;
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');
const Web3 = require('web3');

// Configuration Blockchain (Ethereum Testnet)
const web3 = new Web3(process.env.ETHEREUM_RPC_URL);
const contractABI = [...]; // ABI du contrat DEO Token
const contractAddress = process.env.CONTRACT_ADDRESS;
const deoContract = new web3.eth.Contract(contractABI, contractAddress);

// Syst√®me de r√©compenses DEO Token
router.post('/rewards/claim', auth, async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Calculer les r√©compenses de l'utilisateur
    const rewards = await calculateUserRewards(userId);
    
    if (rewards.totalTokens === 0) {
      return res.status(400).json({ error: 'Aucune r√©compense √† r√©clamer' });
    }

    // Transf√©rer les tokens
    const transaction = await deoContract.methods
      .transfer(req.user.eth_address, web3.utils.toWei(rewards.totalTokens.toString(), 'ether'))
      .send({
        from: process.env.ADMIN_WALLET,
        gas: 200000
      });

    // Enregistrer la transaction
    await pool.query(
      `INSERT INTO token_transactions 
       (user_id, type, amount, transaction_hash, status) 
       VALUES ($1, $2, $3, $4, $5)`,
      [userId, 'reward', rewards.totalTokens, transaction.transactionHash, 'completed']
    );

    res.json({
      message: 'R√©compenses r√©clam√©es avec succ√®s',
      tokens: rewards.totalTokens,
      transactionHash: transaction.transactionHash
    });

  } catch (error) {
    console.error('Reward claim error:', error);
    res.status(500).json({ error: 'Erreur lors de la r√©clamation' });
  }
});

async function calculateUserRewards(userId) {
  // Calcul bas√© sur l'engagement
  const [posts, likes, comments, follows] = await Promise.all([
    pool.query('SELECT COUNT(*) FROM posts WHERE user_id = $1 AND created_at > NOW() - INTERVAL \'7 days\'', [userId]),
    pool.query('SELECT COUNT(*) FROM likes WHERE user_id = $1 AND created_at > NOW() - INTERVAL \'7 days\'', [userId]),
    pool.query('SELECT COUNT(*) FROM comments WHERE user_id = $1 AND created_at > NOW() - INTERVAL \'7 days\'', [userId]),
    pool.query('SELECT COUNT(*) FROM follows WHERE follower_id = $1 AND created_at > NOW() - INTERVAL \'7 days\'', [userId])
  ]);

  const postCount = parseInt(posts.rows[0].count);
  const likeCount = parseInt(likes.rows[0].count);
  const commentCount = parseInt(comments.rows[0].count);
  const followCount = parseInt(follows.rows[0].count);

  // Formule de r√©compense
  const totalTokens = 
    (postCount * 10) + 
    (likeCount * 1) + 
    (commentCount * 2) + 
    (followCount * 5);

  return {
    totalTokens,
    breakdown: {
      posts: postCount * 10,
      likes: likeCount * 1,
      comments: commentCount * 2,
      follows: followCount * 5
    }
  };
}

// NFT pour contenu premium
router.post('/nft/mint', auth, async (req, res) => {
  const { postId, metadata } = req.body;
  
  try {
    const post = await pool.query(
      'SELECT * FROM posts WHERE id = $1 AND user_id = $2',
      [postId, req.user.id]
    );

    if (post.rows.length === 0) {
      return res.status(404).json({ error: 'Post non trouv√©' });
    }

    // Mint NFT sur blockchain
    const transaction = await deoContract.methods
      .mintNFT(req.user.eth_address, JSON.stringify(metadata))
      .send({
        from: process.env.ADMIN_WALLET,
        gas: 500000
      });

    // Enregistrer le NFT
    await pool.query(
      `INSERT INTO nfts 
       (user_id, post_id, token_id, metadata, transaction_hash) 
       VALUES ($1, $2, $3, $4, $5)`,
      [req.user.id, postId, transaction.events.Transfer.returnValues.tokenId, metadata, transaction.transactionHash]
    );

    res.json({
      message: 'NFT cr√©√© avec succ√®s',
      tokenId: transaction.events.Transfer.returnValues.tokenId,
      transactionHash: transaction.transactionHash
    });

  } catch (error) {
    console.error('NFT minting error:', error);
    res.status(500).json({ error: 'Erreur lors de la cr√©ation du NFT' });
  }
});

module.exports = router;
```


```sql
-- Table pour les transactions token
CREATE TABLE IF NOT EXISTS token_transactions (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  type VARCHAR(20) NOT NULL, -- reward, transfer, purchase
  amount DECIMAL(18,8) NOT NULL,
  transaction_hash VARCHAR(66) UNIQUE,
  status VARCHAR(20) DEFAULT 'pending',
  created_at TIMESTAMP DEFAULT now()
);

-- Table pour les NFTs
CREATE TABLE IF NOT EXISTS nfts (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  post_id INTEGER REFERENCES posts(id) ON DELETE SET NULL,
  token_id INTEGER NOT NULL UNIQUE,
  metadata JSONB NOT NULL,
  transaction_hash VARCHAR(66) UNIQUE,
  created_at TIMESTAMP DEFAULT now()
);

-- Table pour les r√©compenses
CREATE TABLE IF NOT EXISTS user_rewards (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  reward_type VARCHAR(50) NOT NULL,
  tokens_earned DECIMAL(18,8) NOT NULL,
  reference_id INTEGER, -- ID du post, like, etc.
  created_at TIMESTAMP DEFAULT now()
);

-- Ajouter l'adresse Ethereum aux utilisateurs
ALTER TABLE users ADD COLUMN IF NOT EXISTS eth_address VARCHAR(42);
ALTER TABLE users ADD COLUMN IF NOT EXISTS total_tokens DECIMAL(18,8) DEFAULT 0;

-- Index pour les performances
CREATE INDEX IF NOT EXISTS idx_token_transactions_user ON token_transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_nfts_user ON nfts(user_id);
CREATE INDEX IF NOT EXISTS idx_user_rewards_user ON user_rewards(user_id);
```



```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, FlatList, Alert } from 'react-native';
import API from '../api';
import i18n from '../i18n';

export default function RewardsScreen() {
  const [rewards, setRewards] = useState([]);
  const [totalTokens, setTotalTokens] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    loadRewards();
    loadTokenBalance();
  }, []);

  async function loadRewards() {
    try {
      const r = await API.get('/rewards/history');
      setRewards(r.data);
    } catch (e) {
      console.error('Error loading rewards:', e);
    }
  }

  async function loadTokenBalance() {
    try {
      const r = await API.get('/user/token-balance');
      setTotalTokens(r.data.balance);
    } catch (e) {
      console.error('Error loading token balance:', e);
    }
  }

  async function claimRewards() {
    setIsLoading(true);
    try {
      const r = await API.post('/rewards/claim');
      Alert.alert(i18n.t('rewards.success'), i18n.t('rewards.claimed_success'));
      loadTokenBalance();
      loadRewards();
    } catch (e) {
      Alert.alert(i18n.t('common.error'), e.response?.data?.error || i18n.t('rewards.claim_error'));
    } finally {
      setIsLoading(false);
    }
  }

  function formatTokens(amount) {
    return parseFloat(amount).toFixed(2);
  }

  return (
    <View style={styles.container}>
      {/* Solde de tokens */}
      <View style={styles.balanceCard}>
        <Text style={styles.balanceTitle}>{i18n.t('rewards.your_tokens')}</Text>
        <Text style={styles.balanceAmount}>{formatTokens(totalTokens)} DEO</Text>
        <Text style={styles.balanceSubtitle}>{i18n.t('rewards.available_balance')}</Text>
        
        <TouchableOpacity 
          style={[styles.claimButton, isLoading && styles.claimButtonDisabled]}
          onPress={claimRewards}
          disabled={isLoading}
        >
          <Text style={styles.claimButtonText}>
            {isLoading ? i18n.t('common.loading') : i18n.t('rewards.claim_rewards')}
          </Text>
        </TouchableOpacity>
      </View>

      {/* Historique des r√©compenses */}
      <Text style={styles.sectionTitle}>{i18n.t('rewards.reward_history')}</Text>
      
      <FlatList
        data={rewards}
        keyExtractor={item => String(item.id)}
        renderItem={({ item }) => (
          <View style={styles.rewardItem}>
            <View style={styles.rewardInfo}>
              <Text style={styles.rewardType}>{i18n.t(`rewards.${item.type}`)}</Text>
              <Text style={styles.rewardDate}>
                {new Date(item.created_at).toLocaleDateString()}
              </Text>
            </View>
            <Text style={styles.rewardAmount}>+{formatTokens(item.amount)} DEO</Text>
          </View>
        )}
        ListEmptyComponent={
          <Text style={styles.emptyText}>{i18n.t('rewards.no_rewards')}</Text>
        }
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  balanceCard: {
    backgroundColor: '#2a2a2a',
    padding: 20,
    borderRadius: 12,
    alignItems: 'center',
    marginBottom: 20
  },
  balanceTitle: {
    color: '#999',
    fontSize: 16,
    marginBottom: 8
  },
  balanceAmount: {
    color: '#4a90e2',
    fontSize: 36,
    fontWeight: 'bold',
    marginBottom: 4
  },
  balanceSubtitle: {
    color: '#666',
    fontSize: 14,
    marginBottom: 20
  },
  claimButton: {
    backgroundColor: '#4a90e2',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8
  },
  claimButtonDisabled: {
    backgroundColor: '#666'
  },
  claimButtonText: {
    color: '#ffffff',
    fontWeight: 'bold',
    fontSize: 16
  },
  sectionTitle: {
    color: '#ffffff',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 16
  },
  rewardItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8
  },
  rewardInfo: {
    flex: 1
  },
  rewardType: {
    color: '#ffffff',
    fontWeight: 'bold',
    marginBottom: 4
  },
  rewardDate: {
    color: '#999',
    fontSize: 12
  },
  rewardAmount: {
    color: '#2ecc71',
    fontWeight: 'bold',
    fontSize: 16
  },
  emptyText: {
    color: '#999',
    textAlign: 'center',
    marginTop: 50
  }
});
```



```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const auth = require('../middleware/authMiddleware');

// Syst√®me de niveaux et badges
class GamificationSystem {
  static async calculateUserLevel(userId) {
    const engagement = await this.calculateEngagementScore(userId);
    
    const levels = [
      { level: 1, minScore: 0, name: 'Nouveau', badge: 'üü¢' },
      { level: 2, minScore: 100, name: 'Actif', badge: 'üîµ' },
      { level: 3, minScore: 500, name: 'Influenceur', badge: 'üü£' },
      { level: 4, minScore: 2000, name: 'Star', badge: 'üü°' },
      { level: 5, minScore: 5000, name: 'L√©gende', badge: 'üî¥' }
    ];

    const userLevel = levels
      .slice()
      .reverse()
      .find(level => engagement >= level.minScore) || levels[0];

    return {
      level: userLevel.level,
      name: userLevel.name,
      badge: userLevel.badge,
      score: engagement,
      nextLevel: levels.find(l => l.minScore > engagement),
      progress: this.calculateProgress(engagement, userLevel, levels)
    };
  }

  static async calculateEngagementScore(userId) {
    const [posts, likes, comments, follows, daysActive] = await Promise.all([
      pool.query('SELECT COUNT(*) FROM posts WHERE user_id = $1', [userId]),
      pool.query('SELECT COUNT(*) FROM likes WHERE user_id = $1', [userId]),
      pool.query('SELECT COUNT(*) FROM comments WHERE user_id = $1', [userId]),
      pool.query('SELECT COUNT(*) FROM follows WHERE follower_id = $1', [userId]),
      pool.query('SELECT COUNT(DISTINCT DATE(created_at)) FROM posts WHERE user_id = $1', [userId])
    ]);

    const postCount = parseInt(posts.rows[0].count);
    const likeCount = parseInt(likes.rows[0].count);
    const commentCount = parseInt(comments.rows[0].count);
    const followCount = parseInt(follows.rows[0].count);
    const activeDays = parseInt(daysActive.rows[0].count);

    return (
      (postCount * 10) +
      (likeCount * 1) +
      (commentCount * 2) +
      (followCount * 5) +
      (activeDays * 20)
    );
  }

  static calculateProgress(score, currentLevel, levels) {
    const nextLevel = levels.find(l => l.minScore > currentLevel.minScore);
    if (!nextLevel) return 100;

    const range = nextLevel.minScore - currentLevel.minScore;
    const progress = ((score - currentLevel.minScore) / range) * 100;
    
    return Math.min(Math.max(progress, 0), 100);
  }

  static async awardBadges(userId) {
    const badges = [];
    const userStats = await this.getUserStats(userId);

    // Badge de premier post
    if (userStats.postCount >= 1) {
      badges.push({ id: 'first_post', name: 'Premier Pas', emoji: 'üéØ' });
    }

    // Badge de popularit√©
    if (userStats.followerCount >= 100) {
      badges.push({ id: 'popular', name: 'Populaire', emoji: '‚≠ê' });
    }

    // Badge d'engagement
    if (userStats.likeCount >= 1000) {
      badges.push({ id: 'engaged', name: 'Engag√©', emoji: 'üíñ' });
    }

    // Badge de r√©gularit√©
    if (userStats.activeDays >= 30) {
      badges.push({ id: 'consistent', name: 'R√©gulier', emoji: 'üìÖ' });
    }

    // Sauvegarder les badges
    for (const badge of badges) {
      await pool.query(
        `INSERT INTO user_badges (user_id, badge_id, badge_name, emoji) 
         VALUES ($1, $2, $3, $4) 
         ON CONFLICT DO NOTHING`,
        [userId, badge.id, badge.name, badge.emoji]
      );
    }

    return badges;
  }

  static async getUserStats(userId) {
    const [posts, likes, followers, activeDays] = await Promise.all([
      pool.query('SELECT COUNT(*) FROM posts WHERE user_id = $1', [userId]),
      pool.query('SELECT COUNT(*) FROM likes WHERE user_id = $1', [userId]),
      pool.query('SELECT COUNT(*) FROM follows WHERE following_id = $1', [userId]),
      pool.query('SELECT COUNT(DISTINCT DATE(created_at)) FROM posts WHERE user_id = $1', [userId])
    ]);

    return {
      postCount: parseInt(posts.rows[0].count),
      likeCount: parseInt(likes.rows[0].count),
      followerCount: parseInt(followers.rows[0].count),
      activeDays: parseInt(activeDays.rows[0].count)
    };
  }
}

// Obtenir le niveau et les badges de l'utilisateur
router.get('/gamification/profile', auth, async (req, res) => {
  try {
    const [level, badges] = await Promise.all([
      GamificationSystem.calculateUserLevel(req.user.id),
      GamificationSystem.awardBadges(req.user.id)
    ]);

    res.json({
      level,
      badges,
      stats: await GamificationSystem.getUserStats(req.user.id)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Classement des utilisateurs
router.get('/gamification/leaderboard', auth, async (req, res) => {
  try {
    const leaderboard = await pool.query(`
      SELECT 
        u.id,
        u.name,
        u.avatar_url,
        COUNT(DISTINCT p.id) * 10 +
        COUNT(DISTINCT l.id) * 1 +
        COUNT(DISTINCT c.id) * 2 +
        COUNT(DISTINCT f.id) * 5 as engagement_score,
        COUNT(DISTINCT DATE(p.created_at)) * 20 as consistency_score
      FROM users u
      LEFT JOIN posts p ON p.user_id = u.id
      LEFT JOIN likes l ON l.user_id = u.id
      LEFT JOIN comments c ON c.user_id = u.id
      LEFT JOIN follows f ON f.follower_id = u.id
      GROUP BY u.id, u.name, u.avatar_url
      ORDER BY (engagement_score + consistency_score) DESC
      LIMIT 100
    `);

    res.json(leaderboard.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```sql
-- Table pour les badges des utilisateurs
CREATE TABLE IF NOT EXISTS user_badges (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  badge_id VARCHAR(50) NOT NULL,
  badge_name VARCHAR(100) NOT NULL,
  emoji VARCHAR(10) NOT NULL,
  awarded_at TIMESTAMP DEFAULT now(),
  UNIQUE(user_id, badge_id)
);

-- Table pour les achievements
CREATE TABLE IF NOT EXISTS user_achievements (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  achievement_type VARCHAR(50) NOT NULL,
  progress INTEGER DEFAULT 0,
  target INTEGER NOT NULL,
  completed_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT now(),
  UNIQUE(user_id, achievement_type)
);

-- Table pour les r√©compenses quotidiennes
CREATE TABLE IF NOT EXISTS daily_rewards (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  reward_type VARCHAR(50) NOT NULL,
  reward_value INTEGER NOT NULL,
  claimed_at TIMESTAMP DEFAULT now(),
  UNIQUE(user_id, DATE(claimed_at))
);

-- Index pour les performances
CREATE INDEX IF NOT EXISTS idx_user_badges_user ON user_badges(user_id);
CREATE INDEX IF NOT EXISTS idx_user_achievements_user ON user_achievements(user_id);
CREATE INDEX IF NOT EXISTS idx_daily_rewards_user ON daily_rewards(user_id);
```


```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const adminAuth = require('../middleware/adminAuth');
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const archiver = require('archiver');

// Sauvegarde compl√®te de la base de donn√©es
router.post('/backup/full', adminAuth, async (req, res) => {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupDir = path.join(__dirname, '../backups');
    const backupFile = `deo-backup-${timestamp}.sql`;
    const backupPath = path.join(backupDir, backupFile);
    
    // Cr√©er le dossier de backup s'il n'existe pas
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }

    // Commande de sauvegarde PostgreSQL
    const command = `pg_dump ${process.env.DATABASE_URL} > ${backupPath}`;
    
    exec(command, async (error, stdout, stderr) => {
      if (error) {
        console.error('Backup error:', error);
        return res.status(500).json({ error: 'Erreur de sauvegarde' });
      }

      // Compresser le fichier
      const compressedPath = `${backupPath}.gz`;
      const compressCommand = `gzip ${backupPath}`;
      
      exec(compressCommand, (compressError) => {
        if (compressError) {
          console.error('Compression error:', compressError);
          return res.status(500).json({ error: 'Erreur de compression' });
        }

        // Enregistrer le backup dans la base de donn√©es
        pool.query(
          `INSERT INTO backups (filename, size_mb, status) 
           VALUES ($1, $2, $3)`,
          [
            `${backupFile}.gz`,
            Math.round(fs.statSync(compressedPath).size / (1024 * 1024)),
            'completed'
          ]
        );

        res.json({
          message: 'Sauvegarde compl√®te cr√©√©e avec succ√®s',
          filename: `${backupFile}.gz`,
          downloadUrl: `/api/backup/download/${backupFile}.gz`
        });
      });
    });

  } catch (error) {
    console.error('Backup error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Sauvegarde incr√©mentielle
router.post('/backup/incremental', adminAuth, async (req, res) => {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupFile = `deo-incremental-${timestamp}.sql`;
    const backupPath = path.join(__dirname, '../backups', backupFile);

    // Sauvegarder seulement les donn√©es r√©centes (24h)
    const command = `pg_dump ${process.env.DATABASE_URL} --data-only --where="created_at > NOW() - INTERVAL '24 hours'" > ${backupPath}`;
    
    exec(command, (error) => {
      if (error) {
        return res.status(500).json({ error: 'Erreur de sauvegarde incr√©mentielle' });
      }

      res.json({
        message: 'Sauvegarde incr√©mentielle cr√©√©e',
        filename: backupFile
      });
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Restauration de base de donn√©es
router.post('/restore', adminAuth, async (req, res) => {
  const { filename } = req.body;
  
  try {
    const backupPath = path.join(__dirname, '../backups', filename);
    
    if (!fs.existsSync(backupPath)) {
      return res.status(404).json({ error: 'Fichier de sauvegarde non trouv√©' });
    }

    // D√©compresser si n√©cessaire
    let sqlFile = backupPath;
    if (backupPath.endsWith('.gz')) {
      sqlFile = backupPath.replace('.gz', '');
      exec(`gunzip -c ${backupPath} > ${sqlFile}`);
    }

    // Restaurer la base de donn√©es
    const command = `psql ${process.env.DATABASE_URL} < ${sqlFile}`;
    
    exec(command, (error) => {
      if (error) {
        return res.status(500).json({ error: 'Erreur de restauration' });
      }

      // Nettoyer le fichier d√©compress√©
      if (sqlFile !== backupPath) {
        fs.unlinkSync(sqlFile);
      }

      res.json({ message: 'Base de donn√©es restaur√©e avec succ√®s' });
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Liste des sauvegardes
router.get('/backups', adminAuth, async (req, res) => {
  try {
    const backups = await pool.query(`
      SELECT * FROM backups 
      ORDER BY created_at DESC 
      LIMIT 50
    `);

    // V√©rifier les fichiers physiques
    const backupDir = path.join(__dirname, '../backups');
    const files = fs.existsSync(backupDir) ? fs.readdirSync(backupDir) : [];

    res.json({
      databaseBackups: backups.rows,
      physicalFiles: files.filter(f => f.endsWith('.sql') || f.endsWith('.gz'))
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// T√©l√©charger un backup
router.get('/backup/download/:filename', adminAuth, (req, res) => {
  const { filename } = req.params;
  const filePath = path.join(__dirname, '../backups', filename);
  
  if (!fs.existsSync(filePath)) {
    return res.status(404).json({ error: 'Fichier non trouv√©' });
  }

  res.download(filePath);
});

// Nettoyage automatique des vieux backups
router.post('/backup/cleanup', adminAuth, async (req, res) => {
  try {
    const backupDir = path.join(__dirname, '../backups');
    const files = fs.existsSync(backupDir) ? fs.readdirSync(backupDir) : [];
    
    const now = Date.now();
    const weekAgo = now - (7 * 24 * 60 * 60 * 1000);
    
    let deletedCount = 0;
    
    files.forEach(file => {
      const filePath = path.join(backupDir, file);
      const stats = fs.statSync(filePath);
      
      if (stats.mtimeMs < weekAgo) {
        fs.unlinkSync(filePath);
        deletedCount++;
      }
    });

    // Nettoyer la table des backups
    await pool.query(`
      DELETE FROM backups 
      WHERE created_at < NOW() - INTERVAL '7 days'
    `);

    res.json({ 
      message: `Nettoyage termin√©: ${deletedCount} fichiers supprim√©s` 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
```



```sql
-- Table pour suivre les sauvegardes
CREATE TABLE IF NOT EXISTS backups (
  id SERIAL PRIMARY KEY,
  filename VARCHAR(255) NOT NULL UNIQUE,
  size_mb DECIMAL(8,2),
  status VARCHAR(20) DEFAULT 'completed',
  created_at TIMESTAMP DEFAULT now()
);

-- Table pour l'audit des op√©rations admin
CREATE TABLE IF NOT EXISTS admin_audit_log (
  id SERIAL PRIMARY KEY,
  admin_id INTEGER REFERENCES users(id),
  action VARCHAR(100) NOT NULL,
  resource_type VARCHAR(50),
  resource_id INTEGER,
  details JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP DEFAULT now()
);

-- Table pour les param√®tres syst√®me
CREATE TABLE IF NOT EXISTS system_settings (
  id SERIAL PRIMARY KEY,
  setting_key VARCHAR(100) UNIQUE NOT NULL,
  setting_value TEXT,
  data_type VARCHAR(20) DEFAULT 'string',
  description TEXT,
  updated_at TIMESTAMP DEFAULT now(),
  updated_by INTEGER REFERENCES users(id)
);

-- Index pour les performances
CREATE INDEX IF NOT EXISTS idx_backups_created ON backups(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_admin_audit_admin ON admin_audit_log(admin_id);
CREATE INDEX IF NOT EXISTS idx_admin_audit_created ON admin_audit_log(created_at DESC);
```


```javascript
const express = require('express');
const router = express.Router();
const pool = require('../db');
const adminAuth = require('../middleware/adminAuth');
const os = require('os');
const { exec } = require('child_process');

// Tableau de bord syst√®me
router.get('/system/dashboard', adminAuth, async (req, res) => {
  try {
    // M√©triques syst√®me
    const systemMetrics = {
      // Usage CPU
      cpu: {
        loadAverage: os.loadavg(),
        cores: os.cpus().length,
        usage: await getCPUUsage()
      },
      // M√©moire
      memory: {
        total: Math.round(os.totalmem() / (1024 * 1024)),
        free: Math.round(os.freemem() / (1024 * 1024)),
        used: Math.round((os.totalmem() - os.freemem()) / (1024 * 1024))
      },
      // Disque
      disk: await getDiskUsage(),
      // Uptime
      uptime: Math.round(os.uptime() / 60), // en minutes
      // R√©seau
      network: os.networkInterfaces()
    };

    // M√©triques base de donn√©es
    const dbMetrics = await pool.query(`
      SELECT 
        (SELECT COUNT(*) FROM users) as user_count,
        (SELECT COUNT(*) FROM posts) as post_count,
        (SELECT COUNT(*) FROM messages) as message_count,
        (SELECT COUNT(*) FROM users WHERE created_at > NOW() - INTERVAL '24 hours') as new_users_24h,
        (SELECT COUNT(*) FROM posts WHERE created_at > NOW() - INTERVAL '24 hours') as new_posts_24h,
        (SELECT COUNT(*) FROM reports WHERE status = 'PENDING') as pending_reports
    `);

    // Performance des requ√™tes
    const slowQueries = await pool.query(`
      SELECT 
        query, 
        calls,
        total_time,
        mean_time,
        rows
      FROM pg_stat_statements 
      ORDER BY mean_time DESC 
      LIMIT 10
    `);

    res.json({
      system: systemMetrics,
      database: dbMetrics.rows[0],
      performance: {
        slowQueries: slowQueries.rows,
        activeConnections: await getActiveConnections()
      },
      timestamp: new Date()
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Gestion des param√®tres syst√®me
router.get('/system/settings', adminAuth, async (req, res) => {
  try {
    const settings = await pool.query(`
      SELECT * FROM system_settings 
      ORDER BY setting_key
    `);
    
    res.json(settings.rows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/system/settings', adminAuth, async (req, res) => {
  const { key, value, dataType = 'string' } = req.body;
  
  try {
    await pool.query(`
      INSERT INTO system_settings (setting_key, setting_value, data_type, updated_by) 
      VALUES ($1, $2, $3, $4)
      ON CONFLICT (setting_key) 
      DO UPDATE SET 
        setting_value = $2,
        data_type = $3,
        updated_by = $4,
        updated_at = NOW()
    `, [key, value, dataType, req.user.id]);

    // Journaliser l'action
    await pool.query(`
      INSERT INTO admin_audit_log (admin_id, action, resource_type, details)
      VALUES ($1, $2, $3, $4)
    `, [req.user.id, 'UPDATE_SETTING', 'system', { key, value }]);

    res.json({ message: 'Param√®tre mis √† jour' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Red√©marrage des services
router.post('/system/restart-service', adminAuth, async (req, res) => {
  const { service } = req.body;
  
  try {
    const allowedServices = ['nginx', 'postgresql', 'redis'];
    
    if (!allowedServices.includes(service)) {
      return res.status(400).json({ error: 'Service non autoris√©' });
    }

    exec(`sudo systemctl restart ${service}`, (error) => {
      if (error) {
        return res.status(500).json({ error: `Erreur red√©marrage ${service}` });
      }

      res.json({ message: `${service} red√©marr√© avec succ√®s` });
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Logs syst√®me
router.get('/system/logs', adminAuth, async (req, res) => {
  const { type = 'application', lines = 100 } = req.query;
  
  try {
    const logFiles = {
      application: '/var/log/deo/application.log',
      error: '/var/log/deo/error.log',
      access: '/var/log/nginx/access.log'
    };

    const logFile = logFiles[type];
    if (!logFile) {
      return res.status(400).json({ error: 'Type de log non support√©' });
    }

    exec(`tail -n ${lines} ${logFile}`, (error, stdout) => {
      if (error) {
        return res.status(500).json({ error: 'Erreur lecture logs' });
      }

      res.json({
        type,
        lines: stdout.split('\n').filter(line => line.trim())
      });
    });

  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Fonctions helper
function getCPUUsage() {
  return new Promise((resolve) => {
    const start = os.cpus();
    
    setTimeout(() => {
      const end = os.cpus();
      const usage = [];
      
      for (let i = 0; i < start.length; i++) {
        const startTotal = Object.values(start[i].times).reduce((a, b) => a + b);
        const endTotal = Object.values(end[i].times).reduce((a, b) => a + b);
        
        const startIdle = start[i].times.idle;
        const endIdle = end[i].times.idle;
        
        const total = endTotal - startTotal;
        const idle = endIdle - startIdle;
        
        usage.push(100 - (100 * idle / total));
      }
      
      resolve(usage);
    }, 1000);
  });
}

function getDiskUsage() {
  return new Promise((resolve) => {
    exec('df -h /', (error, stdout) => {
      if (error) return resolve({});
      
      const lines = stdout.split('\n');
      if (lines.length < 2) return resolve({});
      
      const parts = lines[1].split(/\s+/);
      resolve({
        total: parts[1],
        used: parts[2],
        available: parts[3],
        usage: parts[4]
      });
    });
  });
}

async function getActiveConnections() {
  const result = await pool.query(`
    SELECT count(*) as count 
    FROM pg_stat_activity 
    WHERE state = 'active'
  `);
  
  return parseInt(result.rows[0].count);
}

module.exports = router;
```



```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, ScrollView, TouchableOpacity, StyleSheet, Alert, RefreshControl } from 'react-native';
import API from '../api';
import i18n from '../i18n';

export default function AdminDashboard() {
  const [systemMetrics, setSystemMetrics] = useState(null);
  const [dbMetrics, setDbMetrics] = useState(null);
  const [refreshing, setRefreshing] = useState(false);

  useEffect(() => {
    loadDashboard();
  }, []);

  async function loadDashboard() {
    setRefreshing(true);
    try {
      const [systemRes, dbRes] = await Promise.all([
        API.get('/admin/system/dashboard'),
        API.get('/admin/database/metrics')
      ]);
      
      setSystemMetrics(systemRes.data);
      setDbMetrics(dbRes.data);
    } catch (e) {
      Alert.alert('Erreur', 'Impossible de charger le tableau de bord');
    } finally {
      setRefreshing(false);
    }
  }

  async function restartService(service) {
    Alert.alert(
      'Red√©marrer le service',
      `√ätes-vous s√ªr de vouloir red√©marrer ${service} ?`,
      [
        { text: 'Annuler', style: 'cancel' },
        { 
          text: 'Red√©marrer', 
          style: 'destructive',
          onPress: async () => {
            try {
              await API.post('/admin/system/restart-service', { service });
              Alert.alert('Succ√®s', `${service} red√©marr√©`);
            } catch (e) {
              Alert.alert('Erreur', 'Red√©marrage √©chou√©');
            }
          }
        }
      ]
    );
  }

  if (!systemMetrics) {
    return (
      <View style={styles.container}>
        <Text style={styles.loadingText}>Chargement...</Text>
      </View>
    );
  }

  return (
    <ScrollView 
      style={styles.container}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={loadDashboard} />
      }
    >
      <Text style={styles.title}>ü¶Ö Tableau de Bord Admin</Text>

      {/* M√©triques Syst√®me */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Syst√®me</Text>
        
        <View style={styles.metricsGrid}>
          <View style={styles.metricCard}>
            <Text style={styles.metricValue}>{systemMetrics.system.cpu.cores}</Text>
            <Text style={styles.metricLabel}>C≈ìurs CPU</Text>
          </View>
          
          <View style={styles.metricCard}>
            <Text style={styles.metricValue}>
              {systemMetrics.system.memory.usage}%
            </Text>
            <Text style={styles.metricLabel}>M√©moire</Text>
          </View>
          
          <View style={styles.metricCard}>
            <Text style={styles.metricValue}>
              {Math.round(systemMetrics.system.uptime / 60)}h
            </Text>
            <Text style={styles.metricLabel}>Uptime</Text>
          </View>
        </View>
      </View>

      {/* M√©triques Base de Donn√©es */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Base de Donn√©es</Text>
        
        <View style={styles.metricsGrid}>
          <View style={styles.metricCard}>
            <Text style={styles.metricValue}>{dbMetrics?.user_count}</Text>
            <Text style={styles.metricLabel}>Utilisateurs</Text>
          </View>
          
          <View style={styles.metricCard}>
            <Text style={styles.metricValue}>{dbMetrics?.post_count}</Text>
            <Text style={styles.metricLabel}>Posts</Text>
          </View>
          
          <View style={styles.metricCard}>
            <Text style={styles.metricValue}>{dbMetrics?.pending_reports}</Text>
            <Text style={styles.metricLabel}>Signalements</Text>
          </View>
        </View>
      </View>

      {/* Actions Admin */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Actions</Text>
        
        <TouchableOpacity 
          style={styles.actionButton}
          onPress={() => restartService('nginx')}
        >
          <Text style={styles.actionText}>üîÑ Red√©marrer Nginx</Text>
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={styles.actionButton}
          onPress={() => restartService('postgresql')}
        >
          <Text style={styles.actionText}>üóÑÔ∏è Red√©marrer PostgreSQL</Text>
        </TouchableOpacity>
        
        <TouchableOpacity 
          style={styles.actionButton}
          onPress={createBackup}
        >
          <Text style={styles.actionText}>üíæ Sauvegarde</Text>
        </TouchableOpacity>
      </View>

      {/* Statut des Services */}
      <View style={styles.section}>
        <Text style={styles.sectionTitle}>Statut des Services</Text>
        
        <View style={styles.serviceStatus}>
          <View style={styles.serviceItem}>
            <Text style={styles.serviceName}>API DEO</Text>
            <Text style={styles.statusOnline}>‚óè En ligne</Text>
          </View>
          
          <View style={styles.serviceItem}>
            <Text style={styles.serviceName}>Base de donn√©es</Text>
            <Text style={styles.statusOnline}>‚óè En ligne</Text>
          </View>
          
          <View style={styles.serviceItem}>
            <Text style={styles.serviceName}>Redis</Text>
            <Text style={styles.statusOnline}>‚óè En ligne</Text>
          </View>
        </View>
      </View>
    </ScrollView>
  );
}

async function createBackup() {
  try {
    const response = await API.post('/admin/backup/full');
    Alert.alert('Succ√®s', 'Sauvegarde cr√©√©e avec succ√®s');
  } catch (e) {
    Alert.alert('Erreur', '√âchec de la sauvegarde');
  }
}

const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    padding: 16,
    backgroundColor: '#1a1a1a'
  },
  loadingText: {
    color: '#ffffff',
    textAlign: 'center',
    marginTop: 50
  },
  title: {
    color: '#ffffff',
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center'
  },
  section: {
    marginBottom: 24
  },
  sectionTitle: {
    color: '#ffffff',
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 12
  },
  metricsGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between'
  },
  metricCard: {
    flex: 1,
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginHorizontal: 4
  },
  metricValue: {
    color: '#4a90e2',
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 4
  },
  metricLabel: {
    color: '#999',
    fontSize: 12
  },
  actionButton: {
    backgroundColor: '#2a2a2a',
    padding: 16,
    borderRadius: 8,
    marginBottom: 8
  },
  actionText: {
    color: '#ffffff',
    fontSize: 16
  },
  serviceStatus: {
    backgroundColor: '#2a2a2a',
    borderRadius: 8,
    padding: 12
  },
  serviceItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: 8
  },
  serviceName: {
    color: '#ffffff',
    fontSize: 16
  },
  statusOnline: {
    color: '#2ecc71',
    fontWeight: 'bold'
  }
});
```


```javascript
const pool = require('../db');

class MonitoringSystem {
  static async trackRequest(req, res, next) {
    const start = Date.now();
    
    // Capturer la r√©ponse
    const originalSend = res.send;
    res.send = function(data) {
      const duration = Date.now() - start;
      
      // Journaliser les requ√™tes lentes
      if (duration > 1000) { // Plus d'1 seconde
        MonitoringSystem.logSlowRequest(req, res, duration);
      }
      
      // M√©triques de performance
      MonitoringSystem.recordMetrics(req, res, duration);
      
      originalSend.call(this, data);
    };
    
    next();
  }
  
  static async logSlowRequest(req, res, duration) {
    try {
      await pool.query(`
        INSERT INTO performance_logs 
        (endpoint, method, duration_ms, user_id, status_code) 
        VALUES ($1, $2, $3, $4, $5)
      `, [
        req.path,
        req.method,
        duration,
        req.user?.id || null,
        res.statusCode
      ]);
    } catch (error) {
      console.error('Error logging slow request:', error);
    }
  }
  
  static async recordMetrics(req, res, duration) {
    try {
      // Incr√©menter les compteurs
      await pool.query(`
        INSERT INTO api_metrics 
        (endpoint, method, request_count, total_duration, date) 
        VALUES ($1, $2, 1, $3, CURRENT_DATE)
        ON CONFLICT (endpoint, method, date) 
        DO UPDATE SET 
          request_count = api_metrics.request_count + 1,
          total_duration = api_metrics.total_duration + $3
      `, [req.path, req.method, duration]);
      
    } catch (error) {
      console.error('Error recording metrics:', error);
    }
  }
  
  static async getPerformanceReport(days = 7) {
    try {
      const report = await pool.query(`
        SELECT 
          endpoint,
          method,
          SUM(request_count) as total_requests,
          AVG(total_duration / request_count) as avg_duration,
          MAX(total_duration / request_count) as max_duration,
          COUNT(*) as days_tracked
        FROM api_metrics 
        WHERE date > CURRENT_DATE - $1::integer
        GROUP BY endpoint, method
        ORDER BY total_requests DESC
      `, [days]);
      
      return report.rows;
    } catch (error) {
      console.error('Error getting performance report:', error);
      return [];
    }
  }
}

module.exports = { MonitoringSystem };
```


```sql
-- Table pour les logs de performance
CREATE TABLE IF NOT EXISTS performance_logs (
  id SERIAL PRIMARY KEY,
  endpoint VARCHAR(500) NOT NULL,
  method VARCHAR(10) NOT NULL,
  duration_ms INTEGER NOT NULL,
  user_id INTEGER REFERENCES users(id),
  status_code INTEGER,
  created_at TIMESTAMP DEFAULT now()
);

-- Table pour les m√©triques API
CREATE TABLE IF NOT EXISTS api_metrics (
  id SERIAL PRIMARY KEY,
  endpoint VARCHAR(500) NOT NULL,
  method VARCHAR(10) NOT NULL,
  request_count INTEGER DEFAULT 0,
  total_duration BIGINT DEFAULT 0,
  date DATE NOT NULL,
  UNIQUE(endpoint, method, date)
);

-- Table pour les erreurs syst√®me
CREATE TABLE IF NOT EXISTS error_logs (
  id SERIAL PRIMARY KEY,
  error_message TEXT NOT NULL,
  stack_trace TEXT,
  endpoint VARCHAR(500),
  user_id INTEGER REFERENCES users(id),
  severity VARCHAR(20) DEFAULT 'error',
  resolved BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT now()
);

-- Index pour les performances
CREATE INDEX IF NOT EXISTS idx_performance_logs_created ON performance_logs(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_performance_logs_duration ON performance_logs(duration_ms DESC);
CREATE INDEX IF NOT EXISTS idx_api_metrics_date ON api_metrics(date DESC);
CREATE INDEX IF NOT EXISTS idx_error_logs_severity ON error_logs(severity, created_at DESC);
```



```bash
cd backend
npm install
cp .env.example .env
# Configurer les variables d'environnement
npm run migrate
npm start
cd mobile
npm install
expo start
deo/
‚îú‚îÄ‚îÄ üì± mobile/                 # Application React Native
‚îú‚îÄ‚îÄ üóÑÔ∏è backend/               # API Node.js/Express
‚îú‚îÄ‚îÄ üê≥ docker-compose.yml     # D√©ploiement Docker
‚îú‚îÄ‚îÄ üìä analytics/             # Scripts d'analyse
‚îî‚îÄ‚îÄ üìö documentation/         # Documentation technique
# Base de donn√©es
DATABASE_URL=postgresql://user:pass@localhost:5432/deo
REDIS_URL=redis://localhost:6379

# S√©curit√©
JWT_SECRET=your_super_secret_key
JWT_REFRESH_SECRET=your_refresh_secret

# AWS S3
AWS_ACCESS_KEY_ID=your_key
AWS_SECRET_ACCESS_KEY=your_secret
S3_BUCKET=deo-bucket

# APIs externes
OPENAI_API_KEY=your_openai_key
GOOGLE_VISION_API_KEY=your_vision_key

# Email
EMAIL_HOST=smtp.gmail.com
EMAIL_USER=your_email
EMAIL_PASS=your_password

-- Utilisateurs
users (id, phone, email, password_hash, name, bio, avatar_url, is_vip, language, ...)

-- Contenu
posts (id, user_id, content, image_url, like_count, comment_count, ...)
messages (id, sender_id, receiver_id, encrypted_content, ...)
comments (id, post_id, user_id, content, ...)

-- Social
follows (follower_id, following_id)
likes (user_id, post_id)

-- Mod√©ration
reports (reporter_id, reported_user_id, reason, status)
user_bans (user_id, reason, duration_hours)

-- Mon√©tisation
payments (user_id, amount, status)
user_rewards (user_id, reward_type, tokens_earned)
docker-compose up -d
# Backend
npm run build
npm start

# Mobile
expo build:android
expo build:ios
## üìä **SCRIPT DE D√âPLOIEMENT FINAL - deploy-production.sh**
```bash
#!/bin/bash

set -e

echo "ü¶Ö D√âPLOIEMENT DEO PRODUCTION üöÄ"

# Variables
ENV="production"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups/deo"
DOCKER_COMPOSE="docker-compose -f docker-compose.yml -f docker-compose.production.yml"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Fonctions
log_info() {
    echo -e "${GREEN}‚ÑπÔ∏è $1${NC}"
}

log_warn() {
    echo -e "${YELLOW}‚ö†Ô∏è $1${NC}"
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

# V√©rifications pr√©-d√©ploiement
check_prerequisites() {
    log_info "V√©rification des pr√©requis..."
    
    # V√©rifier Docker
    if ! command -v docker &> /dev/null; then
        log_error "Docker n'est pas install√©"
        exit 1
    fi
    
    # V√©rifier Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        log_error "Docker Compose n'est pas install√©"
        exit 1
    fi
    
    # V√©rifier l'espace disque
    AVAILABLE_SPACE=$(df / | awk 'NR==2 {print $4}')
    if [ "$AVAILABLE_SPACE" -lt 5242880 ]; then  # 5GB minimum
        log_error "Espace disque insuffisant"
        exit 1
    fi
    
    log_info "‚úÖ Pr√©requis valid√©s"
}

# Sauvegarde avant d√©ploiement
create_backup() {
    log_info "Cr√©ation de la sauvegarde..."
    
    mkdir -p $BACKUP_DIR
    
    # Sauvegarde base de donn√©es
    $DOCKER_COMPOSE exec postgres pg_dumpall -U deo_user > "$BACKUP_DIR/backup_$TIMESTAMP.sql"
    
    # Sauvegarde des uploads
    tar -czf "$BACKUP_DIR/uploads_$TIMESTAMP.tar.gz" -C backend uploads/
    
    log_info "‚úÖ Sauvegarde cr√©√©e: $BACKUP_DIR/backup_$TIMESTAMP.sql"
}

# D√©ploiement
deploy_application() {
    log_info "D√©ploiement de l'application..."
    
    # Pull des derni√®res images
    log_info "R√©cup√©ration des derni√®res images..."
    $DOCKER_COMPOSE pull
    
    # Arr√™t des services
    log_info "Arr√™t des services existants..."
    $DOCKER_COMPOSE down --timeout 30
    
    # D√©marrage des services
    log_info "D√©marrage des services..."
    $DOCKER_COMPOSE up -d
    
    # Attendre que les services soient pr√™ts
    log_info "Attente du d√©marrage des services..."
    sleep 30
    
    # V√©rifier la sant√© des services
    check_services_health
    
    # Migrations base de donn√©es
    log_info "Ex√©cution des migrations..."
    $DOCKER_COMPOSE exec backend node sql/migrate.js
    
    log_info "‚úÖ Application d√©ploy√©e"
}

# V√©rification sant√© des services
check_services_health() {
    log_info "V√©rification de la sant√© des services..."
    
    # V√©rifier PostgreSQL
    if ! $DOCKER_COMPOSE exec postgres pg_isready -U deo_user; then
        log_error "PostgreSQL n'est pas pr√™t"
        exit 1
    fi
    
    # V√©rifier Redis
    if ! $DOCKER_COMPOSE exec redis redis-cli ping | grep -q "PONG"; then
        log_error "Redis n'est pas pr√™t"
        exit 1
    fi
    
    # V√©rifier Backend
    if ! curl -f http://localhost:4000/api/health > /dev/null 2>&1; then
        log_error "Backend API n'est pas accessible"
        exit 1
    fi
    
    log_info "‚úÖ Tous les services sont en ligne"
}

# Nettoyage
cleanup() {
    log_info "Nettoyage des ressources inutiles..."
    
    # Nettoyer les images Docker non utilis√©es
    docker image prune -f
    
    # Nettoyer les anciennes sauvegardes (garder 7 jours)
    find $BACKUP_DIR -name "backup_*.sql" -mtime +7 -delete
    find $BACKUP_DIR -name "uploads_*.tar.gz" -mtime +7 -delete
    
    log_info "‚úÖ Nettoyage termin√©"
}

# Tests post-d√©ploiement
run_post_deployment_tests() {
    log_info "Ex√©cution des tests post-d√©ploiement..."
    
    # Test d'authentification
    if ! curl -s -X POST http://localhost:4000/api/auth/health-check | grep -q "success"; then
        log_error "Test d'authentification √©chou√©"
        exit 1
    fi
    
    # Test de base de donn√©es
    if ! $DOCKER_COMPOSE exec backend node scripts/test-db-connection.js; then
        log_error "Test base de donn√©es √©chou√©"
        exit 1
    fi
    
    log_info "‚úÖ Tests post-d√©ploiement r√©ussis"
}

# Rapport de d√©ploiement
generate_deployment_report() {
    log_info "G√©n√©ration du rapport de d√©ploiement..."
    
    REPORT_FILE="/tmp/deo_deployment_$TIMESTAMP.log"
    
    cat > $REPORT_FILE << EOF
ü¶Ö RAPPORT DE D√âPLOIEMENT DEO
============================
Date: $(date)
Version: $(git describe --tags 2>/dev/null || git rev-parse --short HEAD)
Environnement: $ENV

SERVICES D√âPLOY√âS:
‚úÖ PostgreSQL: $($DOCKER_COMPOSE ps postgres | grep Up && echo "En ligne" || echo "Hors ligne")
‚úÖ Redis: $($DOCKER_COMPOSE ps redis | grep Up && echo "En ligne" || echo "Hors ligne")
‚úÖ Backend: $($DOCKER_COMPOSE ps backend | grep Up && echo "En ligne" || echo "Hors ligne")
‚úÖ Nginx: $($DOCKER_COMPOSE ps nginx | grep Up && echo "En ligne" || echo "Hors ligne")

RESSOURCES:
üìä M√©moire utilis√©e: $(docker stats --no-stream --format "{{.MemUsage}}" deo-backend-1)
üíæ Stockage: $(du -sh backend/uploads | cut -f1)

SAUVEGARDES:
üíæ Derni√®re sauvegarde: backup_$TIMESTAMP.sql

STATISTIQUES:
üë• Utilisateurs: $(curl -s http://localhost:4000/api/admin/stats | grep -o '"users":[0-9]*' | cut -d: -f2)
üìù Posts: $(curl -s http://localhost:4000/api/admin/stats | grep -o '"posts":[0-9]*' | cut -d: -f2)

ACTIONS:
üîß Migrations ex√©cut√©es: OUI
üßπ Nettoyage effectu√©: OUI
üß™ Tests pass√©s: OUI

Prochaines √©tapes:
1. V√©rifier les logs d'application
2. Tester les fonctionnalit√©s principales
3. Surveiller les m√©triques de performance
4. Informer l'√©quipe du d√©ploiement r√©ussi

EOF

    log_info "üìÑ Rapport g√©n√©r√©: $REPORT_FILE"
    cat $REPORT_FILE
}

# Flux principal
main() {
    log_info "üöÄ D√©but du d√©ploiement DEO Production"
    
    check_prerequisites
    create_backup
    deploy_application
    run_post_deployment_tests
    cleanup
    generate_deployment_report
    
    log_info "üéâ D√âPLOIEMENT R√âUSSI !"
    log_info "üåê Application accessible sur: https://deo-social.com"
    log_info "üìä Tableau de bord admin: https://deo-social.com/admin"
}

# Ex√©cution
main "$@"
const { Pool } = require('pg');
const fs = require('fs');
const path = require('path');

class DatabaseMigrator {
  constructor() {
    this.pool = new Pool({ connectionString: process.env.DATABASE_URL });
    this.migrationsTable = 'schema_migrations';
    this.migrationsDir = path.join(__dirname, 'migrations');
  }

  async initialize() {
    // Cr√©er la table des migrations si elle n'existe pas
    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS ${this.migrationsTable} (
        id SERIAL PRIMARY KEY,
        version VARCHAR(50) UNIQUE NOT NULL,
        name VARCHAR(255) NOT NULL,
        applied_at TIMESTAMP DEFAULT NOW()
      )
    `);
  }

  async getAppliedMigrations() {
    const result = await this.pool.query(
      `SELECT version FROM ${this.migrationsTable} ORDER BY applied_at`
    );
    return result.rows.map(row => row.version);
  }

  async getPendingMigrations() {
    const applied = await this.getAppliedMigrations();
    const allMigrations = fs.readdirSync(this.migrationsDir)
      .filter(file => file.endsWith('.sql'))
      .sort();

    return allMigrations.filter(migration => !applied.includes(migration));
  }

  async runMigration(migrationFile) {
    const migrationPath = path.join(this.migrationsDir, migrationFile);
    const sql = fs.readFileSync(migrationPath, 'utf8');
    
    console.log(`üîÑ Ex√©cution de la migration: ${migrationFile}`);
    
    // Ex√©cuter dans une transaction
    const client = await this.pool.connect();
    
    try {
      await client.query('BEGIN');
      
      // Ex√©cuter le SQL de migration
      await client.query(sql);
      
      // Enregistrer la migration
      await client.query(
        `INSERT INTO ${this.migrationsTable} (version, name) VALUES ($1, $2)`,
        [migrationFile, migrationFile.replace('.sql', '')]
      );
      
      await client.query('COMMIT');
      console.log(`‚úÖ Migration r√©ussie: ${migrationFile}`);
      
    } catch (error) {
      await client.query('ROLLBACK');
      console.error(`‚ùå √âchec de la migration: ${migrationFile}`, error);
      throw error;
    } finally {
      client.release();
    }
  }

  async runAllMigrations() {
    await this.initialize();
    
    const pendingMigrations = await this.getPendingMigrations();
    
    if (pendingMigrations.length === 0) {
      console.log('‚úÖ Aucune migration en attente');
      return;
    }

    console.log(`üìã Migrations en attente: ${pendingMigrations.length}`);
    
    for (const migration of pendingMigrations) {
      await this.runMigration(migration);
    }
    
    console.log('üéâ Toutes les migrations ont √©t√© ex√©cut√©es avec succ√®s');
  }

  async createMigration(name) {
    const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, 14);
    const filename = `${timestamp}_${name}.sql`;
    const filepath = path.join(this.migrationsDir, filename);
    
    const template = `-- Migration: ${name}
-- Date: ${new Date().toISOString()}

BEGIN;

-- Votre code de migration ici

-- Exemple:
-- CREATE TABLE nouvelle_table (
--   id SERIAL PRIMARY KEY,
--   created_at TIMESTAMP DEFAULT NOW()
-- );

COMMIT;
`;

    fs.writeFileSync(filepath, template);
    console.log(`üìÑ Migration cr√©√©e: ${filename}`);
    return filename;
  }
}

// Ex√©cution automatique si appel√© directement
if (require.main === module) {
  const migrator = new DatabaseMigrator();
  
  const command = process.argv[2];
  
  switch (command) {
    case 'create':
      const name = process.argv[3];
      if (!name) {
        console.error('‚ùå Usage: node migrate.js create <nom_migration>');
        process.exit(1);
      }
      migrator.createMigration(name);
      break;
      
    case 'run':
      migrator.runAllMigrations()
        .then(() => process.exit(0))
        .catch(error => {
          console.error('‚ùå Erreur lors des migrations:', error);
          process.exit(1);
        });
      break;
      
    case 'status':
      migrator.initialize()
        .then(() => migrator.getPendingMigrations())
        .then(pending => {
          console.log(`üìã Migrations en attente: ${pending.length}`);
          pending.forEach(m => console.log(`  - ${m}`));
        });
      break;
      
    default:
      console.log(`
ü¶Ö Syst√®me de Migration DEO

Usage:
  node migrate.js run          - Ex√©cuter toutes les migrations en attente
  node migrate.js create <nom> - Cr√©er une nouvelle migration
  node migrate.js status       - Voir le statut des migrations

Exemples:
  node migrate.js create add_user_preferences
  node migrate.js run
      `);
  }
}

module.exports = DatabaseMigrator;
{
  "cli": {
    "version": ">= 6.0.0"
  },
  "build": {
    "production": {
      "android": {
        "buildType": "app-bundle"
      },
      "ios": {
        "simulator": false
      },
      "env": {
        "APP_ENV": "production",
        "API_BASE_URL": "https://api.deo-social.com"
      },
      "channel": "production"
    },
    "preview": {
      "android": {
        "buildType": "apk"
      },
      "distribution": "internal",
      "channel": "preview",
      "env": {
        "APP_ENV": "staging",
        "API_BASE_URL": "https://staging.deo-social.com"
      }
    },
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "channel": "development",
      "env": {
        "APP_ENV": "development",
        "API_BASE_URL": "http://localhost:4000"
      }
    }
  }
}